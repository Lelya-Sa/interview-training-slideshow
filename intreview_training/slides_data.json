[
  {
    "id": 0,
    "category": "React ‚Äì Basics",
    "title": "What is the difference between props and state?",
    "content": "\r\n**Props (Properties):**\r\n- Props are **read-only** data passed from parent to child components\r\n- Props are **immutable** - a component cannot change its own props\r\n- Used for passing data down the component tree\r\n- Props flow **unidirectionally** (top to bottom)\r\n\r\n**State:**\r\n- State is **mutable** data managed within a component\r\n- State can be changed using `setState` (class components) or `useState` hook (functional components)\r\n- State changes trigger component re-renders\r\n- State is **local** to the component that owns it\r\n\r\n**Key Difference:** Props are passed in, state is managed internally.\r\n\r\n**Complete Example:**\r\n```javascript\r\n// Parent Component\r\nfunction App() {\r\n  const [count, setCount] = useState(0); // State in parent\r\n  \r\n  return (\r\n    <div>\r\n      <Counter count={count} onIncrement={() => setCount(count + 1)} />\r\n      {/* count and onIncrement are PROPS passed to child */}\r\n    </div>\r\n  );\r\n}\r\n\r\n// Child Component\r\nfunction Counter({ count, onIncrement }) {\r\n  // count and onIncrement are PROPS (read-only, from parent)\r\n  const [localCount, setLocalCount] = useState(0); // STATE (local to this component)\r\n  \r\n  return (\r\n    <div>\r\n      <p>Parent count (prop): {count}</p>\r\n      <p>Local count (state): {localCount}</p>\r\n      <button onClick={onIncrement}>Increment Parent</button>\r\n      <button onClick={() => setLocalCount(localCount + 1)}>Increment Local</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 1,
    "category": "React ‚Äì Basics",
    "title": "What is the Virtual DOM and why is it efficient?",
    "content": "\r\n**Virtual DOM:**\r\n- A lightweight JavaScript representation of the real DOM\r\n- React creates a virtual tree of React elements in memory\r\n- When state changes, React creates a new virtual DOM tree\r\n- React then compares (diffs) the new virtual DOM with the previous one\r\n- Only the **differences** are updated in the real DOM (reconciliation)\r\n\r\n**Why it's efficient:**\r\n- **Batching updates:** Multiple state changes are batched into a single DOM update\r\n- **Minimal DOM manipulation:** Only changed elements are updated, not entire pages\r\n- **Faster comparisons:** Comparing JavaScript objects is faster than DOM operations\r\n- **Optimized diffing algorithm:** React uses efficient algorithms to find minimal changes\r\n\r\n**Example:**\r\n```javascript\r\nfunction Counter() {\r\n  const [count, setCount] = useState(0);\r\n  const [name, setName] = useState('John');\r\n  \r\n  const handleClick = () => {\r\n    setCount(count + 1);  // State change 1\r\n    setName('Jane');      // State change 2\r\n    // React batches these into ONE DOM update!\r\n  };\r\n  \r\n  return (\r\n    <div>\r\n      <h1>{name}</h1>  {/* Only this updates if name changes */}\r\n      <p>{count}</p>    {/* Only this updates if count changes */}\r\n      <button onClick={handleClick}>Update</button>\r\n    </div>\r\n  );\r\n}\r\n\r\n// What happens:\r\n// 1. User clicks button\r\n// 2. React creates new Virtual DOM tree\r\n// 3. Compares with previous Virtual DOM\r\n// 4. Finds only <h1> and <p> changed\r\n// 5. Updates ONLY those elements in real DOM\r\n// 6. Rest of page unchanged (fast!)\r\n```\r\n\r\n\r"
  },
  {
    "id": 2,
    "category": "React ‚Äì Basics",
    "title": "What is JSX? Is it mandatory?",
    "content": "\r\n**JSX (JavaScript XML):**\r\n- A syntax extension that allows writing HTML-like code in JavaScript\r\n- JSX is **transpiled** to `React.createElement()` calls by Babel\r\n- Makes React code more readable and intuitive\r\n\r\n**Is it mandatory?**\r\n- **No**, JSX is not mandatory. You can write React without JSX:\r\n  ```javascript\r\n  // With JSX\r\n  const element = <h1>Hello</h1>;\r\n  \r\n  // Without JSX (equivalent)\r\n  const element = React.createElement('h1', null, 'Hello');\r\n  ```\r\n- However, JSX is the **recommended** and most common way to write React code\r\n\r\n\r"
  },
  {
    "id": 3,
    "category": "React ‚Äì Basics",
    "title": "Why do we need keys in lists?",
    "content": "\r\n**Keys:**\r\n- Special string attributes used to identify which items have changed, been added, or removed\r\n- Keys help React efficiently update the DOM during reconciliation\r\n\r\n**Why they're important:**\r\n- **Performance:** React can quickly identify which items changed without re-rendering everything\r\n- **State preservation:** Keys help React maintain component state correctly when list order changes\r\n- **Avoiding bugs:** Without keys, React may incorrectly reuse components, causing state issues\r\n\r\n**Best practices:**\r\n- Use **unique, stable** identifiers (IDs from data, not array indices)\r\n- Keys should be unique among siblings\r\n- Don't use array index as key if list order can change\r\n\r\n```javascript\r\n// Good\r\n{items.map(item => <Item key={item.id} data={item} />)}\r\n\r\n// Bad (if items can be reordered)\r\n{items.map((item, index) => <Item key={index} data={item} />)}\r\n```\r\n\r\n**Complete Project Example: Todo List App**\r\n\r\n```javascript\r\n// ‚úÖ Project Example: Todo List with Proper Keys\r\nfunction TodoApp() {\r\n  const [todos, setTodos] = useState([\r\n    { id: 1, text: 'Learn React', completed: false },\r\n    { id: 2, text: 'Build Todo App', completed: false },\r\n    { id: 3, text: 'Deploy to production', completed: false }\r\n  ]);\r\n  const [newTodo, setNewTodo] = useState('');\r\n\r\n  // Add new todo\r\n  const addTodo = () => {\r\n    if (newTodo.trim()) {\r\n      const todo = {\r\n        id: Date.now(), // Unique ID (or use UUID in production)\r\n        text: newTodo,\r\n        completed: false\r\n      };\r\n      setTodos([...todos, todo]);\r\n      setNewTodo('');\r\n    }\r\n  };\r\n\r\n  // Delete todo\r\n  const deleteTodo = (id) => {\r\n    setTodos(todos.filter(todo => todo.id !== id));\r\n  };\r\n\r\n  // Toggle completion\r\n  const toggleTodo = (id) => {\r\n    setTodos(todos.map(todo =>\r\n      todo.id === id ? { ...todo, completed: !todo.completed } : todo\r\n    ));\r\n  };\r\n\r\n  // Reorder todos (drag and drop simulation)\r\n  const moveUp = (id) => {\r\n    const index = todos.findIndex(t => t.id === id);\r\n    if (index > 0) {\r\n      const newTodos = [...todos];\r\n      [newTodos[index - 1], newTodos[index]] = [newTodos[index], newTodos[index - 1]];\r\n      setTodos(newTodos);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <input\r\n        value={newTodo}\r\n        onChange={e => setNewTodo(e.target.value)}\r\n        placeholder=\"Add new todo\"\r\n      />\r\n      <button onClick={addTodo}>Add</button>\r\n\r\n      <ul>\r\n        {/* ‚úÖ GOOD: Using unique ID as key */}\r\n        {todos.map(todo => (\r\n          <TodoItem\r\n            key={todo.id}  // Stable, unique identifier\r\n            todo={todo}\r\n            onDelete={deleteTodo}\r\n            onToggle={toggleTodo}\r\n            onMoveUp={moveUp}\r\n          />\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction TodoItem({ todo, onDelete, onToggle, onMoveUp }) {\r\n  const [isEditing, setIsEditing] = useState(false);\r\n  const [editText, setEditText] = useState(todo.text);\r\n\r\n  // State is preserved correctly because of proper key\r\n  // Even when todos are reordered, React knows which component is which\r\n\r\n  return (\r\n    <li style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\r\n      <input\r\n        type=\"checkbox\"\r\n        checked={todo.completed}\r\n        onChange={() => onToggle(todo.id)}\r\n      />\r\n      {isEditing ? (\r\n        <>\r\n          <input\r\n            value={editText}\r\n            onChange={e => setEditText(e.target.value)}\r\n            onBlur={() => {\r\n              setIsEditing(false);\r\n              // Update todo text\r\n            }}\r\n          />\r\n        </>\r\n      ) : (\r\n        <span onDoubleClick={() => setIsEditing(true)}>{todo.text}</span>\r\n      )}\r\n      <button onClick={() => onMoveUp(todo.id)}>‚Üë</button>\r\n      <button onClick={() => onDelete(todo.id)}>Delete</button>\r\n    </li>\r\n  );\r\n}\r\n\r\n// ‚ùå BAD Example: Using index as key\r\nfunction BadTodoApp() {\r\n  const [todos, setTodos] = useState([\r\n    { text: 'Learn React', completed: false },\r\n    { text: 'Build Todo App', completed: false },\r\n    { text: 'Deploy to production', completed: false }\r\n  ]);\r\n\r\n  const deleteTodo = (index) => {\r\n    setTodos(todos.filter((_, i) => i !== index));\r\n  };\r\n\r\n  return (\r\n    <ul>\r\n      {/* ‚ùå BAD: Using index as key */}\r\n      {todos.map((todo, index) => (\r\n        <TodoItem\r\n          key={index}  // ‚ùå Problem: Index changes when items are deleted/reordered!\r\n          todo={todo}\r\n          onDelete={() => deleteTodo(index)}\r\n        />\r\n      ))}\r\n    </ul>\r\n  );\r\n}\r\n\r\n// Problems with index as key:\r\n// 1. If you delete the first item, all remaining items get new keys\r\n// 2. React thinks all items changed and re-renders everything\r\n// 3. Component state (like isEditing) gets mixed up between items\r\n// 4. Performance issues - unnecessary re-renders\r\n// 5. Input values can jump to wrong items when list changes\r\n\r\n// Real-world scenario:\r\n// - User is editing \"Build Todo App\" (index 1)\r\n// - User deletes \"Learn React\" (index 0)\r\n// - Now \"Build Todo App\" becomes index 0\r\n// - React thinks it's a new item (key changed from 1 to 0)\r\n// - Editing state is lost or moved to wrong item!\r\n```\r\n\r\n**Key Takeaways:**\r\n- ‚úÖ **Always use unique IDs** from your data (e.g., `todo.id`, `user.id`, `product.id`)\r\n- ‚úÖ **Keys should be stable** - don't generate random keys on each render\r\n- ‚úÖ **Keys help React track** which items changed, were added, or removed\r\n- ‚ùå **Never use index as key** if list can be reordered, filtered, or items deleted\r\n- ‚ùå **Index as key causes bugs** with component state, form inputs, and performance issues\r\n\r\n\r"
  },
  {
    "id": 4,
    "category": "React ‚Äì Basics",
    "title": "When does a React component re-render?",
    "content": "\r\nA React component re-renders when:\r\n\r\n1. **State changes:** When `setState` is called (class) or state setter from `useState` (hooks)\r\n2. **Props change:** When parent component passes new props\r\n3. **Parent re-renders:** Child components re-render when parent re-renders (unless optimized)\r\n4. **Context value changes:** When a consumed context value changes\r\n5. **Force update:** When `forceUpdate()` is called (class components, rarely used)\r\n\r\n**Note:** Re-rendering doesn't always mean the DOM is updated - React's reconciliation process determines what actually changes.\r\n\r\n**Complete Example:**\r\n```javascript\r\nfunction Parent() {\r\n  const [count, setCount] = useState(0);\r\n  const [name, setName] = useState('John');\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\r\n      <button onClick={() => setName('Jane')}>Name: {name}</button>\r\n      <Child name={name} /> {/* Re-renders when name changes */}\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Child({ name }) {\r\n  console.log('Child rendered'); // Logs when component re-renders\r\n  \r\n  // This component re-renders when:\r\n  // 1. Parent re-renders (because parent state changed)\r\n  // 2. name prop changes\r\n  // 3. But NOT when count changes (if optimized with React.memo)\r\n  \r\n  return <p>Hello, {name}!</p>;\r\n}\r\n\r\n// Example with Context\r\nconst ThemeContext = createContext();\r\n\r\n// üìö EXPLANATION: createContext()\r\n// \r\n// createContext() is NOT a hook - it's a React function that creates a Context object.\r\n// \r\n// What it does:\r\n// 1. Creates a \"channel\" for sharing data between components without prop drilling\r\n// 2. Returns a Context object with two components: Provider and Consumer\r\n// 3. Allows any component in the tree to access the shared data\r\n//\r\n// How it works:\r\n// Step 1: Create the context (usually outside component)\r\n//   const ThemeContext = createContext('light'); // Optional: default value\r\n//\r\n// Step 2: Provide the value (wrap components with Provider)\r\n//   <ThemeContext.Provider value={theme}>\r\n//     <YourComponents />\r\n//   </ThemeContext.Provider>\r\n//\r\n// Step 3: Consume the value (use useContext hook)\r\n//   const theme = useContext(ThemeContext);\r\n//\r\n// Key Points:\r\n// - createContext() is called ONCE (usually at module level, outside components)\r\n// - The Context object itself doesn't hold data - it's just a \"channel\"\r\n// - The Provider component actually provides the data\r\n// - Multiple components can consume the same context\r\n// - Context value can be any type: string, number, object, function, etc.\r\n//\r\n// When to use:\r\n// - When data needs to be shared by many components at different levels\r\n// - To avoid \"prop drilling\" (passing props through many levels)\r\n// - For app-wide data: theme, user authentication, language, etc.\r\n//\r\n// Example breakdown:\r\nconst ThemeContext = createContext('light'); // Creates context with default value 'light'\r\n// This creates:\r\n// - ThemeContext.Provider (component to provide value)\r\n// - ThemeContext.Consumer (component to consume value - old way)\r\n// - ThemeContext (the context object itself)\r\n\r\nfunction App() {\r\n  const [theme, setTheme] = useState('light');\r\n  \r\n  return (\r\n    <ThemeContext.Provider value={theme}>\r\n      <ThemedComponent /> {/* Re-renders when theme changes */}\r\n    </ThemeContext.Provider>\r\n  );\r\n}\r\n\r\nfunction ThemedComponent() {\r\n  const theme = useContext(ThemeContext); // Re-renders when context value changes\r\n  return <div className={theme}>Content</div>;\r\n}\r\n\r\n// üéØ COMPLETE EXAMPLE: Understanding createContext Step-by-Step\r\n\r\n// Step 1: CREATE the context (outside component, at module level)\r\nconst UserContext = createContext(null); // null is default value if no Provider found\r\n\r\n// Step 2: CREATE a Provider component (optional but recommended)\r\nfunction UserProvider({ children }) {\r\n  const [user, setUser] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n  \r\n  useEffect(() => {\r\n    // Simulate fetching user\r\n    fetch('/api/user')\r\n      .then(res => res.json())\r\n      .then(data => {\r\n        setUser(data);\r\n        setLoading(false);\r\n      });\r\n  }, []);\r\n  \r\n  // Provide both user data AND setter function\r\n  const value = {\r\n    user,\r\n    setUser,\r\n    loading\r\n  };\r\n  \r\n  return (\r\n    <UserContext.Provider value={value}>\r\n      {children}\r\n    </UserContext.Provider>\r\n  );\r\n}\r\n\r\n// Step 3: USE the context in any component (no prop drilling needed!)\r\nfunction Header() {\r\n  const { user, loading } = useContext(UserContext); // Access user directly!\r\n  \r\n  if (loading) return <div>Loading...</div>;\r\n  return <header>Welcome, {user?.name}!</header>;\r\n}\r\n\r\nfunction Sidebar() {\r\n  const { user } = useContext(UserContext); // Same context, different component!\r\n  return <aside>User ID: {user?.id}</aside>;\r\n}\r\n\r\nfunction Profile() {\r\n  const { user, setUser } = useContext(UserContext); // Can also update!\r\n  \r\n  const updateName = () => {\r\n    setUser({ ...user, name: 'New Name' });\r\n  };\r\n  \r\n  return (\r\n    <div>\r\n      <p>Name: {user?.name}</p>\r\n      <button onClick={updateName}>Update Name</button>\r\n    </div>\r\n  );\r\n}\r\n\r\n// Step 4: Wrap your app with Provider\r\nfunction App() {\r\n  return (\r\n    <UserProvider> {/* Provides context to all children */}\r\n      <Header />      {/* Can access user */}\r\n      <Sidebar />     {/* Can access user */}\r\n      <Profile />     {/* Can access and update user */}\r\n    </UserProvider>\r\n  );\r\n}\r\n\r\n// üîç What createContext() Actually Returns:\r\nconst MyContext = createContext('default');\r\nconsole.log(MyContext);\r\n// Returns an object with:\r\n// {\r\n//   Provider: Component,  // Used to provide value\r\n//   Consumer: Component,  // Old way to consume (use useContext instead)\r\n//   _currentValue: 'default',  // Internal React property\r\n//   displayName: undefined  // For React DevTools\r\n// }\r\n\r\n// üí° Key Concepts:\r\n// 1. createContext() is called ONCE (not inside components)\r\n// 2. It creates a \"channel\" but doesn't store data\r\n// 3. Provider actually provides the data\r\n// 4. useContext() reads the data from nearest Provider\r\n// 5. If no Provider found, uses default value (or undefined)\r\n// 6. Multiple components can use same context\r\n// 7. Context value can be anything: string, object, function, etc.\r\n```\r\n\r\n\r\n"
  },
  {
    "id": 5,
    "category": "React ‚Äì Hooks",
    "title": "What does useState do?",
    "content": "\r\n`useState` is a Hook that lets you add state to functional components.\r\n\r\n```javascript\r\nconst [state, setState] = useState(initialValue);\r\n```\r\n\r\n- Returns an array with two elements: current state value and a function to update it\r\n- The initial value is only used on the first render\r\n- State updates trigger re-renders\r\n- Multiple `useState` calls can be used for different state variables\r\n\r\n**Complete Example:**\r\n```javascript\r\nfunction Counter() {\r\n  // useState returns [currentValue, setterFunction]\r\n  const [count, setCount] = useState(0); // Initial value: 0\r\n  const [name, setName] = useState('');  // Initial value: empty string\r\n  const [user, setUser] = useState({ name: 'John', age: 25 }); // Object\r\n  \r\n  const increment = () => {\r\n    setCount(count + 1); // Update count\r\n  };\r\n  \r\n  const updateName = () => {\r\n    setName('Jane'); // Update name\r\n  };\r\n  \r\n  const updateUser = () => {\r\n    // For objects, need to create new object (immutability)\r\n    setUser({ ...user, age: 26 }); // Update age, keep name\r\n  };\r\n  \r\n  return (\r\n    <div>\r\n      <p>Count: {count}</p>\r\n      <p>Name: {name}</p>\r\n      <p>User: {user.name}, Age: {user.age}</p>\r\n      <button onClick={increment}>Increment</button>\r\n      <button onClick={updateName}>Change Name</button>\r\n      <button onClick={updateUser}>Update Age</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 6,
    "category": "React ‚Äì Hooks",
    "title": "When do you use useEffect?",
    "content": "\r\n`useEffect` is used for **side effects** in functional components - operations that affect something outside the component's render.\r\n\r\n**Common use cases:**\r\n- **API calls:** Fetching data when component mounts\r\n- **Subscriptions:** Setting up event listeners, WebSocket connections\r\n- **DOM manipulation:** Direct DOM updates (though usually avoidable)\r\n- **Timers:** Setting up intervals or timeouts\r\n- **Cleanup:** Cleaning up resources when component unmounts\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// Example 1: Fetch data on mount\r\nfunction UserProfile({ userId }) {\r\n  const [user, setUser] = useState(null);\r\n  \r\n  useEffect(() => {\r\n    // This runs after component mounts\r\n    async function fetchUser() {\r\n      const response = await fetch(`/api/users/${userId}`);\r\n      const data = await response.json();\r\n      setUser(data);\r\n    }\r\n    fetchUser();\r\n  }, [userId]); // Runs when userId changes\r\n  \r\n  return <div>{user?.name}</div>;\r\n}\r\n\r\n// Example 2: Set up subscription\r\nfunction ChatRoom({ roomId }) {\r\n  useEffect(() => {\r\n    // Set up WebSocket connection\r\n    const socket = new WebSocket(`ws://localhost:3000/room/${roomId}`);\r\n    \r\n    socket.onmessage = (event) => {\r\n      console.log('Message:', event.data);\r\n    };\r\n    \r\n    // Cleanup: Close connection when component unmounts\r\n    return () => {\r\n      socket.close();\r\n    };\r\n  }, [roomId]);\r\n  \r\n  return <div>Chat Room {roomId}</div>;\r\n}\r\n\r\n// Example 3: Update document title\r\nfunction Page({ title }) {\r\n  useEffect(() => {\r\n    // Side effect: Change browser tab title\r\n    document.title = title;\r\n    \r\n    // Cleanup: Reset title when component unmounts\r\n    return () => {\r\n      document.title = 'My App';\r\n    };\r\n  }, [title]); // Runs when title changes\r\n  \r\n  return <h1>{title}</h1>;\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 7,
    "category": "React ‚Äì Hooks",
    "title": "What is the difference between:",
    "content": "   - `useEffect(() => {}, [])`\r\n   - `useEffect(() => {})`\r\n\r\n**`useEffect(() => {}, [])` - Empty dependency array:**\r\n- Runs **once** after the initial render\r\n- Equivalent to `componentDidMount` in class components\r\n- Use for one-time setup (API calls on mount, subscriptions)\r\n\r\n**`useEffect(() => {})` - No dependency array:**\r\n- Runs **after every render** (initial + all updates)\r\n- Equivalent to `componentDidMount` + `componentDidUpdate`\r\n- Usually **not recommended** - can cause infinite loops if state is updated inside\r\n- Use only when you need the effect to run on every render (rare)\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\nfunction Component() {\r\n  const [count, setCount] = useState(0);\r\n  const [name, setName] = useState('John');\r\n  \r\n  // ‚úÖ Runs ONCE after initial render (like componentDidMount)\r\n  useEffect(() => {\r\n    console.log('Component mounted - fetching data');\r\n    fetch('/api/data').then(res => res.json());\r\n  }, []); // Empty array = run once\r\n  \r\n  // ‚ö†Ô∏è Runs on EVERY render (usually bad!)\r\n  useEffect(() => {\r\n    console.log('Rendered!'); // Logs on every state change\r\n    // WARNING: If you update state here, you'll get infinite loop!\r\n  }); // No array = run every render\r\n  \r\n  // ‚úÖ Runs when count changes\r\n  useEffect(() => {\r\n    console.log('Count changed:', count);\r\n  }, [count]); // Only runs when count changes\r\n  \r\n  // ‚úÖ Runs when count OR name changes\r\n  useEffect(() => {\r\n    console.log('Count or name changed');\r\n  }, [count, name]); // Runs when either changes\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\r\n      <button onClick={() => setName('Jane')}>Change Name</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 8,
    "category": "React ‚Äì Hooks",
    "title": "What is cleanup in useEffect?",
    "content": "\r\n**Cleanup function:**\r\n- An optional function returned from `useEffect`\r\n- Runs when the component unmounts OR before the effect runs again (if dependencies change)\r\n- Used to clean up resources to prevent memory leaks\r\n\r\n**Common cleanup scenarios:**\r\n- **Cancel API requests:** Abort fetch requests\r\n- **Remove event listeners:** Prevent memory leaks\r\n- **Clear timers:** Stop intervals/timeouts\r\n- **Close connections:** WebSocket, database connections\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// Example 1: Timer cleanup\r\nfunction Timer() {\r\n  const [seconds, setSeconds] = useState(0);\r\n  \r\n  useEffect(() => {\r\n    const timer = setInterval(() => {\r\n      setSeconds(prev => prev + 1);\r\n    }, 1000);\r\n    \r\n    // Cleanup: Clear timer when component unmounts\r\n    return () => {\r\n      clearInterval(timer); // Prevents memory leak!\r\n    };\r\n  }, []); // Empty deps = runs once on mount\r\n  \r\n  return <div>Timer: {seconds}s</div>;\r\n}\r\n\r\n// Example 2: API request cleanup\r\nfunction UserProfile({ userId }) {\r\n  const [user, setUser] = useState(null);\r\n  \r\n  useEffect(() => {\r\n    const abortController = new AbortController();\r\n    \r\n    async function fetchUser() {\r\n      try {\r\n        const res = await fetch(`/api/users/${userId}`, {\r\n          signal: abortController.signal\r\n        });\r\n        const data = await res.json();\r\n        setUser(data);\r\n      } catch (err) {\r\n        if (err.name !== 'AbortError') {\r\n          console.error(err);\r\n        }\r\n      }\r\n    }\r\n    \r\n    fetchUser();\r\n    \r\n    // Cleanup: Cancel request if component unmounts\r\n    return () => {\r\n      abortController.abort(); // Cancels ongoing request\r\n    };\r\n  }, [userId]);\r\n  \r\n  return <div>{user?.name}</div>;\r\n}\r\n\r\n// Example 3: Event listener cleanup\r\nfunction WindowSize() {\r\n  const [width, setWidth] = useState(window.innerWidth);\r\n  \r\n  useEffect(() => {\r\n    function handleResize() {\r\n      setWidth(window.innerWidth);\r\n    }\r\n    \r\n    window.addEventListener('resize', handleResize);\r\n    \r\n    // Cleanup: Remove listener when component unmounts\r\n    return () => {\r\n      window.removeEventListener('resize', handleResize);\r\n    };\r\n  }, []);\r\n  \r\n  return <div>Window width: {width}px</div>;\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 9,
    "category": "React ‚Äì Hooks",
    "title": "What is the dependency array and why is it important?",
    "content": "\r\n**Dependency array:**\r\n- The second parameter to `useEffect` - an array of values the effect depends on\r\n- Controls **when** the effect runs\r\n\r\n**Why it's important:**\r\n- **Performance:** Prevents unnecessary effect executions\r\n- **Correctness:** Ensures effect has access to latest values\r\n- **Prevents bugs:** Avoids stale closures and infinite loops\r\n\r\n**Rules:**\r\n- **Empty array `[]`:** Effect runs once on mount\r\n- **No array:** Effect runs on every render (usually bad)\r\n- **With dependencies `[a, b]`:** Effect runs when `a` or `b` changes\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\nfunction UserProfile({ userId }) {\r\n  const [user, setUser] = useState(null);\r\n  const [posts, setPosts] = useState([]);\r\n  \r\n  // ‚úÖ Correct: userId in dependency array\r\n  useEffect(() => {\r\n    fetch(`/api/users/${userId}`)\r\n      .then(res => res.json())\r\n      .then(data => setUser(data));\r\n  }, [userId]); // Runs when userId changes\r\n  \r\n  // ‚ùå Wrong: Missing userId dependency\r\n  useEffect(() => {\r\n    fetch(`/api/users/${userId}`) // Using userId but not in deps!\r\n      .then(res => res.json())\r\n      .then(data => setUser(data));\r\n  }, []); // ESLint warning: missing 'userId' in dependencies\r\n  \r\n  // ‚úÖ Correct: Multiple dependencies\r\n  useEffect(() => {\r\n    if (user) {\r\n      fetch(`/api/posts?userId=${userId}&name=${user.name}`)\r\n        .then(res => res.json())\r\n        .then(data => setPosts(data));\r\n    }\r\n  }, [userId, user]); // Runs when userId OR user changes\r\n  \r\n  // ‚úÖ Correct: Empty array (runs once)\r\n  useEffect(() => {\r\n    console.log('Component mounted');\r\n  }, []); // Runs only on mount\r\n  \r\n  // ‚ö†Ô∏è No array (runs every render - usually bad)\r\n  useEffect(() => {\r\n    console.log('Rendered');\r\n  }); // Runs on every render - can cause performance issues\r\n  \r\n  return <div>{user?.name}</div>;\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 10,
    "category": "React ‚Äì Hooks",
    "title": "When should you use useContext?",
    "content": "\r\n`useContext` is used when you need to access context values without prop drilling.\r\n\r\n**Use cases:**\r\n- **Theme:** Dark/light mode across app\r\n- **Authentication:** User data, login status\r\n- **Language:** i18n translations\r\n- **Global state:** Shared state across many components\r\n- **Avoiding prop drilling:** Passing data through many component levels\r\n\r\n**When NOT to use:**\r\n- For data used by only a few closely related components (use props)\r\n- For frequently changing data (can cause performance issues)\r\n\r\n**Complete Example:**\r\n\r\n```javascript\r\n// Step 1: Create context\r\nconst ThemeContext = createContext();\r\nconst UserContext = createContext();\r\n\r\n// Step 2: Create provider component\r\nfunction App() {\r\n  const [theme, setTheme] = useState('light');\r\n  const [user, setUser] = useState({ name: 'John', role: 'user' });\r\n  \r\n  return (\r\n    <ThemeContext.Provider value={{ theme, setTheme }}>\r\n      <UserContext.Provider value={user}>\r\n        <Header />\r\n        <MainContent />\r\n      </UserContext.Provider>\r\n    </ThemeContext.Provider>\r\n  );\r\n}\r\n\r\n// Step 3: Use context in any child component (no prop drilling!)\r\nfunction Header() {\r\n  const { theme, setTheme } = useContext(ThemeContext);\r\n  const user = useContext(UserContext);\r\n  \r\n  return (\r\n    <header className={theme}>\r\n      <h1>Welcome, {user.name}!</h1>\r\n      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>\r\n        Toggle Theme\r\n      </button>\r\n    </header>\r\n  );\r\n}\r\n\r\nfunction MainContent() {\r\n  const { theme } = useContext(ThemeContext);\r\n  // Can access theme without props!\r\n  \r\n  return <main className={theme}>Content</main>;\r\n}\r\n\r\n// Without Context (prop drilling - bad):\r\nfunction AppWithoutContext() {\r\n  const [theme, setTheme] = useState('light');\r\n  \r\n  return (\r\n    <Header theme={theme} setTheme={setTheme} /> {/* Passing through */}\r\n  );\r\n}\r\n\r\nfunction Header({ theme, setTheme }) {\r\n  return (\r\n    <Navbar theme={theme} setTheme={setTheme} /> {/* Passing through again */}\r\n  );\r\n}\r\n\r\nfunction Navbar({ theme, setTheme }) {\r\n  return <nav className={theme}>Nav</nav>; // Finally using it!\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 11,
    "category": "React ‚Äì Hooks",
    "title": "What is the difference between useRef and useState?",
    "content": "\r\n**`useState`:**\r\n- Creates **reactive** state - changes trigger re-renders\r\n- Value persists across renders\r\n- Used for data that affects UI\r\n\r\n**`useRef`:**\r\n- Creates a **mutable** reference that doesn't trigger re-renders\r\n- Value persists across renders (within the same component instance)\r\n- Used for:\r\n  - Accessing DOM elements directly\r\n  - Storing mutable values that don't need to trigger renders\r\n  - Keeping previous values\r\n\r\n**Key difference:** `useState` causes re-renders, `useRef` does not.\r\n\r\n**üéØ When to Use useState vs useRef - Decision Guide:**\r\n\r\n| Scenario | Use | Why |\r\n|----------|-----|-----|\r\n| **Data that affects UI/display** | `useState` | UI needs to update when value changes |\r\n| **Form inputs (controlled)** | `useState` | Need to track and display input value |\r\n| **Counters, toggles, flags** | `useState` | UI shows current value |\r\n| **API data to display** | `useState` | Need to render fetched data |\r\n| **Accessing DOM elements** | `useRef` | Direct DOM manipulation, no UI update needed |\r\n| **Focusing inputs** | `useRef` | Imperative DOM operation |\r\n| **Storing previous values** | `useRef` | Don't want to trigger re-render |\r\n| **Timer IDs, interval references** | `useRef` | Need to clear later, no UI impact |\r\n| **Tracking render count** | `useRef` | Debugging, no UI update needed |\r\n| **Previous props/state** | `useRef` | Compare with current, no re-render |\r\n| **Mutable values that don't affect UI** | `useRef` | Performance - avoid unnecessary renders |\r\n| **Third-party library instances** | `useRef` | Store library objects, no React state needed |\r\n\r\n**Quick Decision Tree:**\r\n\r\n```\r\nDo you need the UI to update when this value changes?\r\n‚îú‚îÄ YES ‚Üí Use useState\r\n‚îÇ   ‚îú‚îÄ Form inputs? ‚Üí useState\r\n‚îÇ   ‚îú‚îÄ Display data? ‚Üí useState\r\n‚îÇ   ‚îú‚îÄ Toggle/switch? ‚Üí useState\r\n‚îÇ   ‚îî‚îÄ Counter? ‚Üí useState\r\n‚îÇ\r\n‚îî‚îÄ NO ‚Üí Use useRef\r\n    ‚îú‚îÄ DOM element access? ‚Üí useRef\r\n    ‚îú‚îÄ Previous value storage? ‚Üí useRef\r\n    ‚îú‚îÄ Timer/interval ID? ‚Üí useRef\r\n    ‚îî‚îÄ Mutable value (no UI)? ‚Üí useRef\r\n```\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// ‚úÖ USE useState - Data affects UI\r\nfunction Counter() {\r\n  const [count, setCount] = useState(0); // ‚úÖ UI shows count\r\n  \r\n  return (\r\n    <div>\r\n      <p>Count: {count}</p> {/* UI updates when count changes */}\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n    </div>\r\n  );\r\n}\r\n\r\n// ‚úÖ USE useState - Form input (controlled)\r\nfunction LoginForm() {\r\n  const [email, setEmail] = useState(''); // ‚úÖ UI shows input value\r\n  const [password, setPassword] = useState(''); // ‚úÖ UI shows input value\r\n  \r\n  return (\r\n    <form>\r\n      <input \r\n        value={email} \r\n        onChange={e => setEmail(e.target.value)} \r\n      />\r\n      <input \r\n        value={password} \r\n        onChange={e => setPassword(e.target.value)} \r\n      />\r\n    </form>\r\n  );\r\n}\r\n\r\n// ‚úÖ USE useRef - DOM access (no UI update needed)\r\nfunction FocusInput() {\r\n  const inputRef = useRef(null); // ‚úÖ No UI update, just DOM access\r\n  \r\n  const handleClick = () => {\r\n    inputRef.current.focus(); // Direct DOM operation\r\n    // No need to re-render component\r\n  };\r\n  \r\n  return (\r\n    <div>\r\n      <input ref={inputRef} />\r\n      <button onClick={handleClick}>Focus Input</button>\r\n    </div>\r\n  );\r\n}\r\n\r\n// ‚úÖ USE useRef - Store previous value (no re-render needed)\r\nfunction CounterWithPrevious() {\r\n  const [count, setCount] = useState(0);\r\n  const prevCountRef = useRef(); // ‚úÖ Store previous, no UI update\r\n  \r\n  useEffect(() => {\r\n    prevCountRef.current = count; // Update ref without re-render\r\n  });\r\n  \r\n  return (\r\n    <div>\r\n      <p>Previous: {prevCountRef.current}</p>\r\n      <p>Current: {count}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n    </div>\r\n  );\r\n}\r\n\r\n// ‚úÖ USE useRef - Timer ID (no UI update)\r\nfunction Timer() {\r\n  const [seconds, setSeconds] = useState(0);\r\n  const intervalRef = useRef(null); // ‚úÖ Store interval ID\r\n  \r\n  const startTimer = () => {\r\n    intervalRef.current = setInterval(() => {\r\n      setSeconds(prev => prev + 1);\r\n    }, 1000);\r\n  };\r\n  \r\n  const stopTimer = () => {\r\n    clearInterval(intervalRef.current); // Clear using ref\r\n  };\r\n  \r\n  return (\r\n    <div>\r\n      <p>Seconds: {seconds}</p>\r\n      <button onClick={startTimer}>Start</button>\r\n      <button onClick={stopTimer}>Stop</button>\r\n    </div>\r\n  );\r\n}\r\n\r\n// ‚úÖ USE useRef - Render count (debugging, no UI)\r\nfunction Component() {\r\n  const renderCount = useRef(0); // ‚úÖ Track renders, no UI update\r\n  renderCount.current += 1;\r\n  \r\n  console.log('Rendered', renderCount.current, 'times');\r\n  // No need to show this in UI, just for debugging\r\n}\r\n\r\n// ‚ùå WRONG - Using useState when you don't need UI update\r\nfunction BadExample() {\r\n  const [inputRef, setInputRef] = useState(null); // ‚ùå Wrong!\r\n  \r\n  // This causes unnecessary re-renders\r\n  // Use useRef instead\r\n}\r\n\r\n// ‚úÖ CORRECT - Using useRef for DOM reference\r\nfunction GoodExample() {\r\n  const inputRef = useRef(null); // ‚úÖ Correct!\r\n  \r\n  // No re-renders when ref changes\r\n}\r\n```\r\n\r\n**Common Mistakes:**\r\n\r\n```javascript\r\n// ‚ùå MISTAKE 1: Using useState for DOM references\r\nconst [inputElement, setInputElement] = useState(null);\r\n// Problem: Causes re-render when ref is set\r\n// Fix: Use useRef instead\r\n\r\n// ‚úÖ CORRECT\r\nconst inputRef = useRef(null);\r\n\r\n// ‚ùå MISTAKE 2: Using useRef for data that should update UI\r\nconst [count, setCount] = useRef(0); // ‚ùå Wrong syntax and wrong hook!\r\n// Problem: UI won't update when count changes\r\n// Fix: Use useState\r\n\r\n// ‚úÖ CORRECT\r\nconst [count, setCount] = useState(0);\r\n\r\n// ‚ùå MISTAKE 3: Using useRef for form inputs (uncontrolled)\r\nfunction Form() {\r\n  const emailRef = useRef(null);\r\n  return <input ref={emailRef} />; // Uncontrolled input\r\n  // Problem: Can't easily validate, reset, or control input\r\n  // Fix: Use useState for controlled inputs (unless you have a good reason)\r\n}\r\n\r\n// ‚úÖ CORRECT (for most cases)\r\nfunction Form() {\r\n  const [email, setEmail] = useState('');\r\n  return <input value={email} onChange={e => setEmail(e.target.value)} />;\r\n}\r\n```\r\n\r\n**Summary Rules:**\r\n- ‚úÖ **useState:** When value changes should update the UI\r\n- ‚úÖ **useRef:** When you need to store a value that doesn't affect rendering\r\n- ‚úÖ **useState:** For controlled inputs, display data, toggles\r\n- ‚úÖ **useRef:** For DOM access, previous values, timer IDs, mutable values without UI impact\r\n\r\n**Important: Unmount/Remount Behavior:**\r\n- When a component **unmounts**, all hooks (including `useRef`) are destroyed\r\n- When the component **remounts**, it's a completely **new instance**\r\n- `useRef` returns to its **initial value** (the default you passed)\r\n- The changed reference value is **lost** - it doesn't persist across unmount/remount\r\n- This is different from `localStorage` or external storage which persists\r\n\r\n**React.memo and Unmount/Remount:**\r\n- **React.memo does NOT prevent unmounting/remounting** - it only prevents re-renders\r\n- **Re-rendering vs Unmounting:**\r\n  - **Re-render:** Component stays mounted, just updates (hooks persist)\r\n  - **Unmount:** Component is removed from DOM (hooks destroyed)\r\n  - **Remount:** Component is added back (new instance, fresh hooks)\r\n- **React.memo** prevents re-renders when props haven't changed, but:\r\n  - If parent conditionally renders the component (`{show && <MemoizedChild />}`), it will still unmount/remount\r\n  - If the component is removed from the tree, React.memo doesn't help - it still unmounts\r\n  - When it remounts, `useRef` still resets to initial value (React.memo doesn't preserve it)\r\n\r\n**üìö Detailed Explanation of Conditional Rendering and React.memo:**\r\n\r\n**What React.memo does:**\r\n- React.memo is a **performance optimization** that prevents re-renders\r\n- It compares props and skips re-rendering if props haven't changed\r\n- It only works when the component **stays in the DOM tree**\r\n\r\n**What React.memo does NOT do:**\r\n- React.memo **cannot prevent unmounting** when a component is removed from the tree\r\n- React.memo **cannot preserve state/refs** across unmount/remount cycles\r\n- React.memo only works for **re-renders**, not for **mount/unmount**\r\n\r\n**Example: Conditional Rendering (Component Removed from Tree)**\r\n\r\n```javascript\r\n// Parent component\r\nfunction Parent() {\r\n  const [showChild, setShowChild] = useState(true);\r\n  const [parentState, setParentState] = useState(0);\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setShowChild(!showChild)}>\r\n        {showChild ? 'Hide' : 'Show'} Child\r\n      </button>\r\n      <button onClick={() => setParentState(parentState + 1)}>\r\n        Parent State: {parentState}\r\n      </button>\r\n      \r\n      {/* Conditional rendering - component is added/removed from tree */}\r\n      {showChild && <MemoizedChild />}\r\n    </div>\r\n  );\r\n}\r\n\r\n// Memoized child component\r\nconst MemoizedChild = React.memo(function Child() {\r\n  const [count, setCount] = useState(0);\r\n  const refValue = useRef(0);\r\n  \r\n  useEffect(() => {\r\n    console.log('Child mounted');\r\n    return () => {\r\n      console.log('Child unmounted - ref value:', refValue.current);\r\n    };\r\n  }, []);\r\n  \r\n  const updateRef = () => {\r\n    refValue.current = 100;\r\n    console.log('Ref updated to:', refValue.current);\r\n  };\r\n  \r\n  return (\r\n    <div>\r\n      <p>Count: {count}</p>\r\n      <p>Ref: {refValue.current}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n      <button onClick={updateRef}>Set Ref to 100</button>\r\n    </div>\r\n  );\r\n});\r\n\r\n// What happens:\r\n//\r\n// SCENARIO 1: Component is shown (showChild = true)\r\n// 1. Component mounts ‚Üí refValue.current = 0\r\n// 2. User clicks \"Set Ref to 100\" ‚Üí refValue.current = 100\r\n// 3. User clicks \"Parent State\" ‚Üí Parent re-renders\r\n//    - React.memo checks: Child has no props, props didn't change\r\n//    - Child does NOT re-render ‚úÖ (React.memo works!)\r\n//    - refValue.current = 100 (preserved because component stayed mounted)\r\n//\r\n// SCENARIO 2: Component is hidden (showChild = false)\r\n// 1. User clicks \"Hide Child\"\r\n// 2. {showChild && <MemoizedChild />} evaluates to false\r\n// 3. Component is REMOVED from the tree\r\n// 4. Component UNMOUNTS ‚ùå (React.memo cannot prevent this!)\r\n// 5. useEffect cleanup runs ‚Üí logs \"Child unmounted - ref value: 100\"\r\n// 6. All hooks are destroyed, refValue.current = 100 is LOST\r\n//\r\n// SCENARIO 3: Component is shown again (showChild = true)\r\n// 1. User clicks \"Show Child\"\r\n// 2. {showChild && <MemoizedChild />} evaluates to <MemoizedChild />\r\n// 3. Component is ADDED to the tree\r\n// 4. Component REMOUNTS (completely new instance)\r\n// 5. useEffect runs ‚Üí logs \"Child mounted\"\r\n// 6. refValue.current = 0 (back to initial value) ‚ùå\r\n// 7. React.memo didn't help - it's a new component instance!\r\n\r\n// Key Points:\r\n// ‚úÖ React.memo prevents re-renders when component STAYS in tree\r\n// ‚ùå React.memo CANNOT prevent unmounting when component is REMOVED from tree\r\n// ‚ùå React.memo CANNOT preserve refs/state across unmount/remount\r\n// \r\n// The conditional rendering ({show && <Component />}) controls whether\r\n// the component exists in the tree at all, which is different from\r\n// re-rendering (component stays, just updates).\r\n```\r\n\r\n**Visual Comparison:**\r\n\r\n```\r\nRE-RENDER (React.memo helps):\r\nParent re-renders ‚Üí Component stays in tree ‚Üí React.memo checks props ‚Üí \r\n  Props same? ‚Üí Skip re-render ‚úÖ ‚Üí Refs preserved ‚úÖ\r\n\r\nUNMOUNT/REMOUNT (React.memo doesn't help):\r\nParent changes showChild to false ‚Üí Component removed from tree ‚Üí \r\n  Component unmounts ‚ùå ‚Üí Refs destroyed ‚ùå ‚Üí \r\nParent changes showChild to true ‚Üí Component added to tree ‚Üí \r\n  Component remounts (new instance) ‚ùå ‚Üí Refs reset to initial ‚ùå\r\n```\r\n- **React.memo preserves ref values during re-renders** (when component stays mounted), but **NOT across unmount/remount**\r\n\r\n**üîç Can You Preserve Component Instance After Unmounting?**\r\n\r\n**Short Answer: No, React does NOT preserve component instances after unmounting.**\r\n\r\nWhen a component unmounts:\r\n- The component instance is **completely destroyed**\r\n- All hooks are **reset**\r\n- All state is **lost**\r\n- All refs are **lost**\r\n- This is by design - React cleans up everything\r\n\r\n**However, there are workarounds to preserve STATE (not the instance itself):**\r\n\r\n**‚úÖ Workaround 1: Keep Component Mounted but Hidden (CSS)**\r\n```javascript\r\nfunction Parent() {\r\n  const [showChild, setShowChild] = useState(true);\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setShowChild(!showChild)}>\r\n        {showChild ? 'Hide' : 'Show'} Child\r\n      </button>\r\n      \r\n      {/* Component stays mounted, just hidden */}\r\n      <div style={{ display: showChild ? 'block' : 'none' }}>\r\n        <Child />\r\n      </div>\r\n      \r\n      {/* OR using visibility */}\r\n      <div style={{ visibility: showChild ? 'visible' : 'hidden' }}>\r\n        <Child />\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Child() {\r\n  const [count, setCount] = useState(0);\r\n  const refValue = useRef(0);\r\n  \r\n  // Component never unmounts, so state/refs are preserved!\r\n  // ‚úÖ This works - component stays in tree, just hidden\r\n  \r\n  return (\r\n    <div>\r\n      <p>Count: {count}</p>\r\n      <p>Ref: {refValue.current}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n    </div>\r\n  );\r\n}\r\n\r\n// üìö EXPLANATION: Why This Component Never Unmounts\r\n//\r\n// The component never unmounts NOT because it lacks a return statement\r\n// (it has one - shown above). It never unmounts because of HOW THE PARENT RENDERS IT.\r\n//\r\n// KEY DIFFERENCE:\r\n//\r\n// ‚ùå CONDITIONAL RENDERING (Component DOES unmount):\r\n//   {showChild && <Child />}\r\n//   When showChild = false, React removes <Child /> from the tree\r\n//   ‚Üí Component UNMOUNTS ‚Üí State/refs are LOST\r\n//\r\n// ‚úÖ ALWAYS RENDERED, JUST HIDDEN (Component NEVER unmounts):\r\n//   <div style={{ display: showChild ? 'block' : 'none' }}>\r\n//     <Child />\r\n//   </div>\r\n//   <Child /> is ALWAYS in the tree (always rendered)\r\n//   ‚Üí Component stays MOUNTED ‚Üí State/refs are PRESERVED\r\n//   ‚Üí Only the CSS changes (hidden vs visible)\r\n//\r\n// VISUAL COMPARISON:\r\n//\r\n// Conditional Rendering:\r\n//   showChild = true  ‚Üí <Child /> exists in tree ‚Üí MOUNTED\r\n//   showChild = false ‚Üí <Child /> removed from tree ‚Üí UNMOUNTED ‚ùå\r\n//   showChild = true  ‚Üí <Child /> added to tree ‚Üí REMOUNTED (new instance)\r\n//\r\n// CSS Hiding:\r\n//   showChild = true  ‚Üí <Child /> in tree, display: block ‚Üí MOUNTED\r\n//   showChild = false ‚Üí <Child /> in tree, display: none ‚Üí STILL MOUNTED ‚úÖ\r\n//   showChild = true  ‚Üí <Child /> in tree, display: block ‚Üí STILL MOUNTED ‚úÖ\r\n//\r\n// The component has a return statement - that's not the issue.\r\n// The issue is whether the component is REMOVED from the React tree or just HIDDEN with CSS.\r\n\r\n// SIDE-BY-SIDE COMPARISON:\r\nfunction ParentComparison() {\r\n  const [showChild, setShowChild] = useState(true);\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setShowChild(!showChild)}>Toggle</button>\r\n      \r\n      {/* ‚ùå METHOD 1: Conditional Rendering - Component UNMOUNTS */}\r\n      <div>\r\n        <h3>Method 1: Conditional Rendering</h3>\r\n        {showChild && <Child />}\r\n        {/* \r\n          When showChild = false:\r\n          - <Child /> is REMOVED from React tree\r\n          - Component UNMOUNTS\r\n          - useEffect cleanup runs\r\n          - State/refs are DESTROYED\r\n        */}\r\n      </div>\r\n      \r\n      {/* ‚úÖ METHOD 2: CSS Hiding - Component STAYS MOUNTED */}\r\n      <div>\r\n        <h3>Method 2: CSS Hiding</h3>\r\n        <div style={{ display: showChild ? 'block' : 'none' }}>\r\n          <Child />\r\n        </div>\r\n        {/* \r\n          When showChild = false:\r\n          - <Child /> STAYS in React tree\r\n          - Component stays MOUNTED\r\n          - Only CSS changes (display: none)\r\n          - State/refs are PRESERVED\r\n        */}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Child() {\r\n  const [count, setCount] = useState(0);\r\n  const refValue = useRef(0);\r\n  \r\n  useEffect(() => {\r\n    console.log('Child mounted');\r\n    return () => {\r\n      console.log('Child unmounted'); // Only logs with Method 1\r\n    };\r\n  }, []);\r\n  \r\n  return (\r\n    <div>\r\n      <p>Count: {count}</p>\r\n      <p>Ref: {refValue.current}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n      <button onClick={() => refValue.current = 100}>Set Ref to 100</button>\r\n    </div>\r\n  );\r\n}\r\n\r\n// Test it:\r\n// Method 1: Click \"Set Ref to 100\", then toggle off/on\r\n//   ‚Üí Ref resets to 0 (component unmounted/remounted)\r\n// Method 2: Click \"Set Ref to 100\", then toggle off/on  \r\n//   ‚Üí Ref stays at 100 (component never unmounted)\r\n```\r\n\r\n**‚úÖ Workaround 2: Lift State to Parent (Never Unmounts)**\r\n```javascript\r\nfunction Parent() {\r\n  const [showChild, setShowChild] = useState(true);\r\n  const [childState, setChildState] = useState(0); // State in parent\r\n  const childRef = useRef(0); // Ref in parent\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setShowChild(!showChild)}>\r\n        {showChild ? 'Hide' : 'Show'} Child\r\n      </button>\r\n      \r\n      {/* State preserved in parent - never unmounts */}\r\n      {showChild && (\r\n        <Child \r\n          state={childState} \r\n          setState={setChildState}\r\n          refValue={childRef}\r\n        />\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Child({ state, setState, refValue }) {\r\n  // State lives in parent, so it's preserved even when child unmounts\r\n  // ‚úÖ This works - state persists in parent\r\n}\r\n```\r\n\r\n**‚úÖ Workaround 3: External State Management (Redux, Context, etc.)**\r\n```javascript\r\n// Using Context (never unmounts)\r\nconst AppContext = createContext();\r\n\r\nfunction App() {\r\n  const [globalState, setGlobalState] = useState({ count: 0, refValue: 0 });\r\n  \r\n  return (\r\n    <AppContext.Provider value={{ globalState, setGlobalState }}>\r\n      <Parent />\r\n    </AppContext.Provider>\r\n  );\r\n}\r\n\r\nfunction Parent() {\r\n  const [showChild, setShowChild] = useState(true);\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setShowChild(!showChild)}>Toggle</button>\r\n      {showChild && <Child />}\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Child() {\r\n  const { globalState, setGlobalState } = useContext(AppContext);\r\n  \r\n  // State in Context - preserved even when component unmounts\r\n  // ‚úÖ This works - state lives outside component\r\n}\r\n```\r\n\r\n**‚úÖ Workaround 4: localStorage/sessionStorage**\r\n```javascript\r\nfunction Child() {\r\n  // Save to localStorage before unmount\r\n  const [count, setCount] = useState(() => {\r\n    return Number(localStorage.getItem('childCount')) || 0;\r\n  });\r\n  \r\n  useEffect(() => {\r\n    localStorage.setItem('childCount', count.toString());\r\n  }, [count]);\r\n  \r\n  useEffect(() => {\r\n    return () => {\r\n      // Cleanup: save final state\r\n      localStorage.setItem('childCount', count.toString());\r\n    };\r\n  }, [count]);\r\n  \r\n  // On remount, reads from localStorage\r\n  // ‚úÖ This works - persists across unmount/remount\r\n}\r\n```\r\n\r\n**‚úÖ Workaround 5: Custom Hook with External Storage**\r\n```javascript\r\n// Custom hook that persists state\r\nfunction usePersistedState(key, initialValue) {\r\n  const [state, setState] = useState(() => {\r\n    const saved = localStorage.getItem(key);\r\n    return saved ? JSON.parse(saved) : initialValue;\r\n  });\r\n  \r\n  useEffect(() => {\r\n    localStorage.setItem(key, JSON.stringify(state));\r\n  }, [key, state]);\r\n  \r\n  return [state, setState];\r\n}\r\n\r\nfunction Child() {\r\n  const [count, setCount] = usePersistedState('childCount', 0);\r\n  // ‚úÖ State persists across unmount/remount via localStorage\r\n}\r\n```\r\n\r\n**‚ùå What Does NOT Work:**\r\n```javascript\r\n// ‚ùå React.memo - doesn't preserve instance\r\nconst MemoizedChild = React.memo(Child); // Still unmounts/remounts\r\n\r\n// ‚ùå useRef - resets on remount\r\nconst ref = useRef(0); // Lost on unmount\r\n\r\n// ‚ùå useState - resets on remount\r\nconst [state, setState] = useState(0); // Lost on unmount\r\n\r\n// ‚ùå Component instance - cannot be preserved\r\n// React destroys it completely\r\n```\r\n\r\n**Summary:**\r\n- ‚ùå **Component instances cannot be preserved** after unmounting\r\n- ‚úÖ **State can be preserved** using external storage (parent state, Context, Redux, localStorage)\r\n- ‚úÖ **Component can stay mounted** but hidden (CSS display/visibility)\r\n- ‚úÖ **Best practice:** Lift state up or use external state management if you need persistence\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// Example 1: Accessing DOM elements\r\nfunction LoginForm() {\r\n  const emailRef = useRef(null);\r\n  const passwordRef = useRef(null);\r\n  \r\n  const handleSubmit = (e) => {\r\n    e.preventDefault();\r\n    // Access DOM directly without re-render\r\n    console.log('Email:', emailRef.current.value);\r\n    console.log('Password:', passwordRef.current.value);\r\n  };\r\n  \r\n  const focusEmail = () => {\r\n    emailRef.current.focus(); // Focus input without state change\r\n  };\r\n  \r\n  return (\r\n    <form onSubmit={handleSubmit}>\r\n      <input ref={emailRef} type=\"email\" />\r\n      <input ref={passwordRef} type=\"password\" />\r\n      <button type=\"button\" onClick={focusEmail}>Focus Email</button>\r\n      <button type=\"submit\">Submit</button>\r\n    </form>\r\n  );\r\n}\r\n\r\n// Example 2: Storing previous value\r\nfunction Counter() {\r\n  const [count, setCount] = useState(0);\r\n  const prevCountRef = useRef();\r\n  \r\n  useEffect(() => {\r\n    prevCountRef.current = count; // Store previous value\r\n  });\r\n  \r\n  const prevCount = prevCountRef.current;\r\n  \r\n  return (\r\n    <div>\r\n      <p>Previous: {prevCount}</p>\r\n      <p>Current: {count}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n    </div>\r\n  );\r\n}\r\n\r\n// Example 3: useRef vs useState\r\nfunction Comparison() {\r\n  const [count, setCount] = useState(0); // ‚úÖ Triggers re-render\r\n  const renderCount = useRef(0); // ‚ùå Doesn't trigger re-render\r\n  \r\n  renderCount.current += 1; // Update without re-render\r\n  \r\n  return (\r\n    <div>\r\n      <p>Count (state): {count}</p>\r\n      <p>Renders (ref): {renderCount.current}</p>\r\n      <button onClick={() => setCount(count + 1)}>\r\n        Increment (causes re-render)\r\n      </button>\r\n    </div>\r\n  );\r\n}\r\n\r\n// Example 4: useRef behavior on unmount/remount\r\nfunction Parent() {\r\n  const [showChild, setShowChild] = useState(true);\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setShowChild(!showChild)}>\r\n        {showChild ? 'Unmount' : 'Mount'} Child\r\n      </button>\r\n      {showChild && <Child />}\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Child() {\r\n  const [count, setCount] = useState(0);\r\n  const refValue = useRef(0); // Initial value: 0\r\n  \r\n  // Change ref value\r\n  const updateRef = () => {\r\n    refValue.current = 100; // Change ref to 100\r\n    console.log('Ref updated to:', refValue.current);\r\n  };\r\n  \r\n  // Log on mount\r\n  useEffect(() => {\r\n    console.log('Component mounted - ref value:', refValue.current);\r\n    // On FIRST mount: refValue.current = 0 (initial value)\r\n    // On REMOUNT: refValue.current = 0 (back to initial, NOT 100!)\r\n    \r\n    return () => {\r\n      console.log('Component unmounting - ref value:', refValue.current);\r\n      // When unmounting, ref might be 100, but this value is LOST\r\n    };\r\n  }, []);\r\n  \r\n  return (\r\n    <div>\r\n      <p>Count (state): {count}</p>\r\n      <p>Ref value: {refValue.current}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment Count</button>\r\n      <button onClick={updateRef}>Set Ref to 100</button>\r\n      <p style={{ color: 'red' }}>\r\n        ‚ö†Ô∏è When you unmount and remount, ref resets to 0!\r\n      </p>\r\n    </div>\r\n  );\r\n}\r\n\r\n// What happens:\r\n// 1. Component mounts ‚Üí refValue.current = 0 (initial)\r\n// 2. User clicks \"Set Ref to 100\" ‚Üí refValue.current = 100\r\n// 3. User clicks \"Unmount Child\" ‚Üí Component unmounts, ref is destroyed\r\n// 4. User clicks \"Mount Child\" ‚Üí Component remounts\r\n// 5. refValue.current = 0 again (NOT 100!) - back to initial value\r\n// \r\n// This is because:\r\n// - Unmount = component instance is destroyed\r\n// - Remount = completely new component instance\r\n// - useRef initializes with the default value you provide\r\n\r\n// ‚úÖ If you need persistence across unmount/remount, use:\r\n// - localStorage\r\n// - sessionStorage\r\n// - External state management (Redux, Context)\r\n// - Parent component state\r\n\r\n// Example 5: React.memo and unmount/remount behavior\r\nfunction ParentWithMemo() {\r\n  const [showChild, setShowChild] = useState(true);\r\n  const [parentCount, setParentCount] = useState(0);\r\n  const [childProp, setChildProp] = useState('initial');\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setShowChild(!showChild)}>\r\n        {showChild ? 'Unmount' : 'Mount'} Child\r\n      </button>\r\n      <button onClick={() => setParentCount(parentCount + 1)}>\r\n        Parent Count: {parentCount} (causes parent re-render)\r\n      </button>\r\n      <button onClick={() => setChildProp('changed')}>\r\n        Change Child Prop\r\n      </button>\r\n      {showChild && <MemoizedChild prop={childProp} />}\r\n    </div>\r\n  );\r\n}\r\n\r\n// Memoized component\r\nconst MemoizedChild = React.memo(function Child({ prop }) {\r\n  const [count, setCount] = useState(0);\r\n  const refValue = useRef(0);\r\n  \r\n  useEffect(() => {\r\n    console.log('Child rendered or mounted');\r\n    // This logs:\r\n    // - On mount\r\n    // - When prop changes (React.memo allows re-render because prop changed)\r\n    // - NOT when parentCount changes (React.memo prevents re-render)\r\n    \r\n    return () => {\r\n      console.log('Child unmounting - ref value:', refValue.current);\r\n    };\r\n  }, [prop]); // Only re-run when prop changes\r\n  \r\n  const updateRef = () => {\r\n    refValue.current = 100;\r\n    console.log('Ref updated to:', refValue.current);\r\n  };\r\n  \r\n  return (\r\n    <div>\r\n      <p>Prop: {prop}</p>\r\n      <p>Count: {count}</p>\r\n      <p>Ref value: {refValue.current}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n      <button onClick={updateRef}>Set Ref to 100</button>\r\n    </div>\r\n  );\r\n});\r\n\r\n// What happens with React.memo:\r\n//\r\n// SCENARIO 1: Re-rendering (component stays mounted)\r\n// 1. Parent re-renders (parentCount changes)\r\n// 2. React.memo checks: prop hasn't changed\r\n// 3. Child does NOT re-render ‚úÖ (React.memo prevents it)\r\n// 4. refValue.current = 100 (preserved! component didn't unmount)\r\n//\r\n// SCENARIO 2: Unmounting/Remounting\r\n// 1. User clicks \"Unmount Child\"\r\n// 2. Component unmounts (removed from tree)\r\n// 3. refValue.current = 100 is LOST ‚ùå (component destroyed)\r\n// 4. User clicks \"Mount Child\"\r\n// 5. Component remounts (new instance)\r\n// 6. refValue.current = 0 (back to initial) ‚ùå\r\n// 7. React.memo doesn't help here - it only prevents re-renders, not unmounts!\r\n//\r\n// SCENARIO 3: Prop changes (component stays mounted)\r\n// 1. User clicks \"Change Child Prop\"\r\n// 2. React.memo checks: prop changed\r\n// 3. Child re-renders ‚úÖ (React.memo allows it because prop changed)\r\n// 4. refValue.current = 100 (preserved! component didn't unmount)\r\n\r\n// Key Takeaways:\r\n// ‚úÖ React.memo preserves ref values during RE-RENDERS (when component stays mounted)\r\n// ‚ùå React.memo does NOT preserve ref values across UNMOUNT/REMOUNT\r\n// ‚úÖ React.memo prevents re-renders when props don't change\r\n// ‚ùå React.memo does NOT prevent unmounting when component is removed from tree\r\n```\r\n\r\n\r"
  },
  {
    "id": 12,
    "category": "React ‚Äì Hooks",
    "title": "When do you use useMemo?",
    "content": "\r\n`useMemo` memoizes (caches) expensive computations to avoid recalculating on every render.\r\n\r\n**Use when:**\r\n- **Expensive calculations:** Complex computations, filtering large arrays\r\n- **Referential equality:** Preventing unnecessary re-renders of child components\r\n- **Derived state:** Computing values from props/state\r\n\r\n**Don't use for:**\r\n- Simple calculations (overhead isn't worth it)\r\n- Every computation (only optimize when needed)\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// Example 1: Expensive calculation\r\nfunction ProductList({ products, filter }) {\r\n  // ‚ùå Without useMemo: Recalculates on every render\r\n  const filteredProducts = products.filter(p => p.category === filter);\r\n  \r\n  // ‚úÖ With useMemo: Only recalculates when products or filter change\r\n  const filteredProducts = useMemo(() => {\r\n    console.log('Filtering products...'); // Only logs when dependencies change\r\n    return products.filter(p => p.category === filter);\r\n  }, [products, filter]);\r\n  \r\n  return (\r\n    <div>\r\n      {filteredProducts.map(product => (\r\n        <Product key={product.id} product={product} />\r\n      ))}\r\n    </div>\r\n  );\r\n}\r\n\r\n// Example 2: Preventing unnecessary re-renders\r\nfunction ExpensiveComponent({ data }) {\r\n  // Expensive computation\r\n  const processedData = useMemo(() => {\r\n    return data.map(item => ({\r\n      ...item,\r\n      computed: expensiveCalculation(item)\r\n    }));\r\n  }, [data]);\r\n  \r\n  return <div>{/* render processedData */}</div>;\r\n}\r\n\r\n// Example 3: When NOT to use useMemo\r\nfunction SimpleComponent({ a, b }) {\r\n  // ‚ùå Don't use for simple calculations\r\n  const sum = useMemo(() => a + b, [a, b]); // Overhead not worth it\r\n  \r\n  // ‚úÖ Just calculate directly\r\n  const sum = a + b; // Simple enough, no need for memoization\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 13,
    "category": "React ‚Äì Hooks",
    "title": "When do you use useCallback?",
    "content": "\r\n`useCallback` memoizes a function to prevent it from being recreated on every render.\r\n\r\n**Use when:**\r\n- **Passing functions to memoized children:** `React.memo` components\r\n- **Dependencies in other hooks:** Functions used in `useEffect`, `useMemo` dependencies\r\n- **Event handlers:** Preventing unnecessary re-renders\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// Example 1: Preventing unnecessary re-renders\r\nconst ExpensiveChild = React.memo(({ onClick, data }) => {\r\n  console.log('Child rendered'); // Only logs when props actually change\r\n  return <button onClick={onClick}>Click me</button>;\r\n});\r\n\r\nfunction Parent() {\r\n  const [count, setCount] = useState(0);\r\n  const [name, setName] = useState('John');\r\n  \r\n  // ‚ùå Without useCallback: New function on every render\r\n  const handleClick = () => {\r\n    console.log('Clicked');\r\n  };\r\n  \r\n  // ‚úÖ With useCallback: Same function reference (unless dependencies change)\r\n  const handleClick = useCallback(() => {\r\n    console.log('Clicked');\r\n  }, []); // Empty deps = function never changes\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\r\n      <button onClick={() => setName('Jane')}>Name: {name}</button>\r\n      {/* Child won't re-render when count/name changes because handleClick is stable */}\r\n      <ExpensiveChild onClick={handleClick} data=\"static\" />\r\n    </div>\r\n  );\r\n}\r\n\r\n// Example 2: useCallback with dependencies\r\nfunction UserProfile({ userId }) {\r\n  const [user, setUser] = useState(null);\r\n  \r\n  // Function recreated only when userId changes\r\n  const fetchUser = useCallback(async () => {\r\n    const res = await fetch(`/api/users/${userId}`);\r\n    const data = await res.json();\r\n    setUser(data);\r\n  }, [userId]);\r\n  \r\n  useEffect(() => {\r\n    fetchUser();\r\n  }, [fetchUser]); // fetchUser is stable (only changes when userId changes)\r\n  \r\n  return <div>{user?.name}</div>;\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 14,
    "category": "React ‚Äì Hooks",
    "title": "Why does useEffect run twice in React 18 (Strict Mode)?",
    "content": "\r\n**React 18 Strict Mode:**\r\n- In development, React 18 intentionally **double-invokes** effects, state updaters, and constructors\r\n- This helps identify side effects and ensure components are resilient\r\n\r\n**Why:**\r\n- **Detect side effects:** Find effects that aren't properly cleaned up\r\n- **Ensure idempotency:** Verify effects can run multiple times safely\r\n- **Prepare for future features:** Like automatic batching, concurrent features\r\n\r\n**Solutions:**\r\n- **Proper cleanup:** Always return cleanup functions\r\n- **Idempotent effects:** Design effects to be safe when run multiple times\r\n- **Note:** This only happens in **development**, not production\r\n\r\n**Complete Example:**\r\n\r\n```javascript\r\nfunction DataFetcher() {\r\n  const [data, setData] = useState(null);\r\n  \r\n  useEffect(() => {\r\n    console.log('Effect running...'); // Logs TWICE in dev (React 18 Strict Mode)\r\n    \r\n    const abortController = new AbortController();\r\n    \r\n    async function fetchData() {\r\n      try {\r\n        const res = await fetch('/api/data', {\r\n          signal: abortController.signal\r\n        });\r\n        const json = await res.json();\r\n        setData(json);\r\n      } catch (err) {\r\n        if (err.name !== 'AbortError') {\r\n          console.error(err);\r\n        }\r\n      }\r\n    }\r\n    \r\n    fetchData();\r\n    \r\n    // Cleanup runs between the two calls in dev\r\n    return () => {\r\n      console.log('Cleanup running...'); // Logs between the two effect calls\r\n      abortController.abort();\r\n    };\r\n  }, []);\r\n  \r\n  // In development with Strict Mode:\r\n  // 1. Effect runs\r\n  // 2. Cleanup runs\r\n  // 3. Effect runs again\r\n  // This helps catch bugs!\r\n  \r\n  // In production:\r\n  // 1. Effect runs once\r\n  // (No double invocation)\r\n  \r\n  return <div>{data && <p>Data loaded</p>}</div>;\r\n}\r\n```\r\n\r\n\r\n"
  },
  {
    "id": 15,
    "category": "React ‚Äì Hooks Comparison (Most Asked in Interviews)",
    "title": "What is the difference between useState and useReducer?",
    "content": "\r\n**`useState`:**\r\n- Simple state management\r\n- Best for: Single values, simple state updates\r\n- Returns: `[state, setState]`\r\n- Updates: Direct value updates\r\n\r\n**`useReducer`:**\r\n- Complex state management\r\n- Best for: Multiple related values, complex state logic\r\n- Returns: `[state, dispatch]`\r\n- Updates: Action-based updates via reducer function\r\n\r\n**When to use:**\r\n- **useState:** Simple state (counters, form inputs, toggles)\r\n- **useReducer:** Complex state (forms with multiple fields, state machines, complex logic)\r\n\r\n**Complete Example:**\r\n```javascript\r\n// ‚úÖ useState - Simple state\r\nfunction Counter() {\r\n  const [count, setCount] = useState(0);\r\n  \r\n  return (\r\n    <div>\r\n      <p>Count: {count}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n      <button onClick={() => setCount(count - 1)}>Decrement</button>\r\n      <button onClick={() => setCount(0)}>Reset</button>\r\n    </div>\r\n  );\r\n}\r\n\r\n// ‚úÖ useReducer - Complex state\r\nconst initialState = { count: 0, step: 1 };\r\n\r\nfunction reducer(state, action) {\r\n  switch (action.type) {\r\n    case 'increment':\r\n      return { ...state, count: state.count + state.step };\r\n    case 'decrement':\r\n      return { ...state, count: state.count - state.step };\r\n    case 'reset':\r\n      return initialState;\r\n    case 'setStep':\r\n      return { ...state, step: action.payload };\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nfunction AdvancedCounter() {\r\n  const [state, dispatch] = useReducer(reducer, initialState);\r\n  \r\n  return (\r\n    <div>\r\n      <p>Count: {state.count}</p>\r\n      <p>Step: {state.step}</p>\r\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\r\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\r\n      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>\r\n      <input \r\n        type=\"number\" \r\n        value={state.step}\r\n        onChange={e => dispatch({ type: 'setStep', payload: Number(e.target.value) })}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 16,
    "category": "React ‚Äì Hooks Comparison (Most Asked in Interviews)",
    "title": "What is the difference between useEffect and useLayoutEffect?",
    "content": "\r\n**`useEffect`:**\r\n- Runs **after** render and paint\r\n- Asynchronous - doesn't block browser painting\r\n- Best for: Data fetching, subscriptions, DOM updates that don't need to be synchronous\r\n- Use in: Most cases\r\n\r\n**`useLayoutEffect`:**\r\n- Runs **synchronously** after DOM mutations but before paint\r\n- Blocks browser painting until it completes\r\n- Best for: DOM measurements, preventing visual flicker\r\n- Use in: Rare cases when you need synchronous DOM access\r\n\r\n**Key Difference:** Timing - `useLayoutEffect` runs before browser paints, `useEffect` runs after.\r\n\r\n**Complete Example:**\r\n```javascript\r\n// useEffect - Runs after paint (most common)\r\nfunction Component() {\r\n  const [width, setWidth] = useState(0);\r\n  \r\n  useEffect(() => {\r\n    // Runs AFTER browser paints\r\n    // User might see flicker if width changes\r\n    const element = document.getElementById('myElement');\r\n    setWidth(element.offsetWidth);\r\n  }, []);\r\n  \r\n  return <div id=\"myElement\" style={{ width: width }}>Content</div>;\r\n}\r\n\r\n// useLayoutEffect - Runs before paint (prevents flicker)\r\nfunction Component() {\r\n  const [width, setWidth] = useState(0);\r\n  \r\n  useLayoutEffect(() => {\r\n    // Runs BEFORE browser paints\r\n    // No flicker - width set before user sees it\r\n    const element = document.getElementById('myElement');\r\n    setWidth(element.offsetWidth);\r\n  }, []);\r\n  \r\n  return <div id=\"myElement\" style={{ width: width }}>Content</div>;\r\n}\r\n\r\n// Real-world: Tooltip positioning\r\nfunction Tooltip({ children, text }) {\r\n  const [position, setPosition] = useState({ top: 0, left: 0 });\r\n  const tooltipRef = useRef(null);\r\n  \r\n  useLayoutEffect(() => {\r\n    // Measure before paint to prevent flicker\r\n    if (tooltipRef.current) {\r\n      const rect = tooltipRef.current.getBoundingClientRect();\r\n      setPosition({ top: rect.top, left: rect.left });\r\n    }\r\n  }, []);\r\n  \r\n  return (\r\n    <div ref={tooltipRef} style={{ position: 'absolute', ...position }}>\r\n      {text}\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 17,
    "category": "React ‚Äì Hooks Comparison (Most Asked in Interviews)",
    "title": "What is the difference between useMemo and useCallback?",
    "content": "\r\n**`useMemo`:**\r\n- Memoizes a **value** (result of computation)\r\n- Returns: Memoized value\r\n- Use for: Expensive calculations, derived data\r\n- Recalculates: When dependencies change\r\n\r\n**`useCallback`:**\r\n- Memoizes a **function**\r\n- Returns: Memoized function reference\r\n- Use for: Functions passed as props, event handlers\r\n- Recreates: When dependencies change\r\n\r\n**Key Difference:** `useMemo` caches values, `useCallback` caches functions.\r\n\r\n**Complete Example:**\r\n```javascript\r\nfunction Parent() {\r\n  const [count, setCount] = useState(0);\r\n  const [items, setItems] = useState([1, 2, 3, 4, 5]);\r\n  \r\n  // ‚úÖ useMemo: Memoize computed value\r\n  const expensiveSum = useMemo(() => {\r\n    console.log('Calculating sum...');\r\n    return items.reduce((sum, item) => sum + item, 0);\r\n  }, [items]); // Only recalculates when items change\r\n  \r\n  // ‚úÖ useCallback: Memoize function\r\n  const handleClick = useCallback(() => {\r\n    console.log('Button clicked');\r\n    setCount(count + 1);\r\n  }, [count]); // Function only recreated when count changes\r\n  \r\n  // ‚ùå Without useCallback: New function on every render\r\n  const handleClickBad = () => {\r\n    setCount(count + 1);\r\n  };\r\n  \r\n  return (\r\n    <div>\r\n      <p>Sum: {expensiveSum}</p>\r\n      <p>Count: {count}</p>\r\n      <ExpensiveChild onClick={handleClick} />\r\n      {/* handleClick is stable, child won't re-render unnecessarily */}\r\n    </div>\r\n  );\r\n}\r\n\r\nconst ExpensiveChild = React.memo(({ onClick }) => {\r\n  console.log('Child rendered');\r\n  return <button onClick={onClick}>Click me</button>;\r\n});\r\n\r\n// When to use each:\r\n// useMemo: const sorted = useMemo(() => items.sort(), [items]);\r\n// useCallback: const handler = useCallback(() => {}, [deps]);\r\n```\r\n\r\n\r"
  },
  {
    "id": 18,
    "category": "React ‚Äì Hooks Comparison (Most Asked in Interviews)",
    "title": "What is the difference between useRef and useState?",
    "content": "\r\n**`useState`:**\r\n- Creates **reactive** state\r\n- Changes trigger **re-renders**\r\n- Used for: Data that affects UI\r\n- Value: Can be accessed via state variable\r\n\r\n**`useRef`:**\r\n- Creates **mutable** reference\r\n- Changes **don't trigger** re-renders\r\n- Used for: DOM access, storing previous values, mutable values\r\n- Value: Accessed via `.current` property\r\n\r\n**Key Difference:** `useState` causes re-renders, `useRef` does not.\r\n\r\n**Complete Example:**\r\n```javascript\r\nfunction Comparison() {\r\n  const [count, setCount] = useState(0); // Triggers re-render\r\n  const renderCount = useRef(0); // Doesn't trigger re-render\r\n  const inputRef = useRef(null); // For DOM access\r\n  \r\n  renderCount.current += 1; // Update without re-render\r\n  \r\n  const focusInput = () => {\r\n    inputRef.current.focus(); // Direct DOM access\r\n  };\r\n  \r\n  return (\r\n    <div>\r\n      <p>Count (state): {count}</p>\r\n      <p>Renders (ref): {renderCount.current}</p>\r\n      <input ref={inputRef} />\r\n      <button onClick={() => setCount(count + 1)}>Increment (re-renders)</button>\r\n      <button onClick={focusInput}>Focus Input (no re-render)</button>\r\n    </div>\r\n  );\r\n}\r\n\r\n// Storing previous value\r\nfunction Counter() {\r\n  const [count, setCount] = useState(0);\r\n  const prevCountRef = useRef();\r\n  \r\n  useEffect(() => {\r\n    prevCountRef.current = count; // Store previous value\r\n  });\r\n  \r\n  const prevCount = prevCountRef.current;\r\n  \r\n  return (\r\n    <div>\r\n      <p>Previous: {prevCount}</p>\r\n      <p>Current: {count}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 19,
    "category": "React ‚Äì Hooks Comparison (Most Asked in Interviews)",
    "title": "What is the difference between useContext and props?",
    "content": "\r\n**Props:**\r\n- Pass data **explicitly** through component tree\r\n- Must pass through every level (prop drilling)\r\n- Clear data flow (easy to trace)\r\n- Best for: Data used by few components\r\n\r\n**`useContext`:**\r\n- Access data **implicitly** from context\r\n- Skip intermediate components\r\n- Less explicit (harder to trace)\r\n- Best for: Data needed by many components\r\n\r\n**When to use:**\r\n- **Props:** Data used by 1-2 levels of children\r\n- **Context:** Data needed by many unrelated components, avoiding prop drilling\r\n\r\n**Complete Example:**\r\n```javascript\r\n// ‚ùå Prop Drilling (bad for many levels)\r\nfunction App() {\r\n  const [user, setUser] = useState({ name: 'John' });\r\n  return <Header user={user} />; // Passing through\r\n}\r\n\r\nfunction Header({ user }) {\r\n  return <Navbar user={user} />; // Passing through again\r\n}\r\n\r\nfunction Navbar({ user }) {\r\n  return <UserMenu user={user} />; // Passing through again\r\n}\r\n\r\nfunction UserMenu({ user }) {\r\n  return <div>{user.name}</div>; // Finally using it!\r\n}\r\n\r\n// ‚úÖ Context (good for many components)\r\nconst UserContext = createContext();\r\n\r\nfunction App() {\r\n  const [user, setUser] = useState({ name: 'John' });\r\n  return (\r\n    <UserContext.Provider value={user}>\r\n      <Header /> {/* No props needed */}\r\n    </UserContext.Provider>\r\n  );\r\n}\r\n\r\nfunction Header() {\r\n  return <Navbar />; // No props\r\n}\r\n\r\nfunction Navbar() {\r\n  return <UserMenu />; // No props\r\n}\r\n\r\nfunction UserMenu() {\r\n  const user = useContext(UserContext); // Direct access!\r\n  return <div>{user.name}</div>;\r\n}\r\n\r\n// When to use each:\r\n// Props: <Button onClick={handleClick} label=\"Click\" />\r\n// Context: Theme, Auth, Language (app-wide data)\r\n```\r\n\r\n\r"
  },
  {
    "id": 20,
    "category": "React ‚Äì Hooks Comparison (Most Asked in Interviews)",
    "title": "What is the difference between useCallback and regular functions?",
    "content": "\r\n**Regular Function:**\r\n- Created **new** on every render\r\n- New function reference each time\r\n- Can cause unnecessary re-renders of memoized children\r\n- Simple and straightforward\r\n\r\n**`useCallback`:**\r\n- **Same** function reference across renders (if deps unchanged)\r\n- Prevents unnecessary re-renders\r\n- Slight performance overhead\r\n- Use when passing to `React.memo` components\r\n\r\n**Complete Example:**\r\n```javascript\r\nconst ExpensiveChild = React.memo(({ onClick, name }) => {\r\n  console.log('Child rendered'); // Only logs when props change\r\n  return <button onClick={onClick}>{name}</button>;\r\n});\r\n\r\nfunction Parent() {\r\n  const [count, setCount] = useState(0);\r\n  const [name, setName] = useState('John');\r\n  \r\n  // ‚ùå Regular function: New function on every render\r\n  const handleClick = () => {\r\n    console.log('Clicked');\r\n  };\r\n  // Child re-renders every time because handleClick is new reference\r\n  \r\n  // ‚úÖ useCallback: Same function reference\r\n  const handleClick = useCallback(() => {\r\n    console.log('Clicked');\r\n  }, []); // Empty deps = function never changes\r\n  // Child doesn't re-render when count/name changes\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\r\n      <button onClick={() => setName('Jane')}>Name: {name}</button>\r\n      <ExpensiveChild onClick={handleClick} name={name} />\r\n      {/* With useCallback: Only re-renders when name changes */}\r\n      {/* Without useCallback: Re-renders on every parent render */}\r\n    </div>\r\n  );\r\n}\r\n\r\n// When to use useCallback:\r\n// ‚úÖ Passing to React.memo components\r\n// ‚úÖ Function in dependency array of other hooks\r\n// ‚ùå Don't use for every function (overhead not worth it)\r\n```\r\n\r\n\r"
  },
  {
    "id": 21,
    "category": "React ‚Äì Hooks Comparison (Most Asked in Interviews)",
    "title": "What is the difference between useMemo and useCallback? (Detailed)",
    "content": "\r\n**`useMemo`:**\r\n- **Purpose:** Cache expensive computations\r\n- **Returns:** Memoized **value**\r\n- **Syntax:** `useMemo(() => value, [deps])`\r\n- **Use for:** Calculations, filtering, sorting, derived state\r\n- **Example:** `const sum = useMemo(() => items.reduce(...), [items])`\r\n\r\n**`useCallback`:**\r\n- **Purpose:** Cache function references\r\n- **Returns:** Memoized **function**\r\n- **Syntax:** `useCallback(() => {}, [deps])`\r\n- **Use for:** Event handlers, functions passed as props\r\n- **Example:** `const handler = useCallback(() => {}, [deps])`\r\n\r\n**Key Insight:** `useCallback(fn, deps)` is equivalent to `useMemo(() => fn, deps)`\r\n\r\n**Complete Example:**\r\n```javascript\r\nfunction ProductList({ products, filter }) {\r\n  const [sortOrder, setSortOrder] = useState('asc');\r\n  \r\n  // ‚úÖ useMemo: Memoize computed value (array)\r\n  const filteredProducts = useMemo(() => {\r\n    console.log('Filtering products...');\r\n    return products.filter(p => p.category === filter);\r\n  }, [products, filter]);\r\n  \r\n  // ‚úÖ useMemo: Memoize sorted array\r\n  const sortedProducts = useMemo(() => {\r\n    console.log('Sorting products...');\r\n    return [...filteredProducts].sort((a, b) => {\r\n      return sortOrder === 'asc' ? a.price - b.price : b.price - a.price;\r\n    });\r\n  }, [filteredProducts, sortOrder]);\r\n  \r\n  // ‚úÖ useCallback: Memoize function\r\n  const handleSort = useCallback(() => {\r\n    setSortOrder(prev => prev === 'asc' ? 'desc' : 'asc');\r\n  }, []); // Function never changes\r\n  \r\n  // ‚úÖ useCallback: Memoize function with dependencies\r\n  const handleFilter = useCallback((category) => {\r\n    // Filter logic\r\n  }, []); // Stable function\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={handleSort}>Sort: {sortOrder}</button>\r\n      {sortedProducts.map(product => (\r\n        <Product key={product.id} product={product} />\r\n      ))}\r\n    </div>\r\n  );\r\n}\r\n\r\n// Equivalent:\r\nconst fn1 = useCallback(() => {}, [deps]);\r\nconst fn2 = useMemo(() => () => {}, [deps]); // Same thing!\r\n```\r\n\r\n\r"
  },
  {
    "id": 22,
    "category": "React ‚Äì Hooks Comparison (Most Asked in Interviews)",
    "title": "What is the difference between custom hooks and regular functions?",
    "content": "\r\n**Regular Function:**\r\n- Can't use React hooks inside\r\n- Just JavaScript function\r\n- No access to React features\r\n- Use for: Utility functions, helpers\r\n\r\n**Custom Hook:**\r\n- Can use React hooks inside\r\n- Must start with \"use\" (convention)\r\n- Shares stateful logic between components\r\n- Use for: Reusable component logic\r\n\r\n**Complete Example:**\r\n```javascript\r\n// ‚ùå Regular function (can't use hooks)\r\nfunction fetchUserData(userId) {\r\n  // Can't use useState, useEffect here!\r\n  return fetch(`/api/users/${userId}`).then(res => res.json());\r\n}\r\n\r\n// ‚úÖ Custom hook (can use hooks)\r\nfunction useUser(userId) {\r\n  const [user, setUser] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n  \r\n  useEffect(() => {\r\n    async function loadUser() {\r\n      try {\r\n        setLoading(true);\r\n        const data = await fetchUserData(userId);\r\n        setUser(data);\r\n      } catch (err) {\r\n        setError(err.message);\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    }\r\n    loadUser();\r\n  }, [userId]);\r\n  \r\n  return { user, loading, error };\r\n}\r\n\r\n// Usage:\r\nfunction UserProfile({ userId }) {\r\n  const { user, loading, error } = useUser(userId); // Reusable!\r\n  \r\n  if (loading) return <div>Loading...</div>;\r\n  if (error) return <div>Error: {error}</div>;\r\n  return <div>{user.name}</div>;\r\n}\r\n\r\n// More custom hooks examples:\r\nfunction useLocalStorage(key, initialValue) {\r\n  const [value, setValue] = useState(() => {\r\n    const item = localStorage.getItem(key);\r\n    return item ? JSON.parse(item) : initialValue;\r\n  });\r\n  \r\n  useEffect(() => {\r\n    localStorage.setItem(key, JSON.stringify(value));\r\n  }, [key, value]);\r\n  \r\n  return [value, setValue];\r\n}\r\n\r\nfunction useDebounce(value, delay) {\r\n  const [debouncedValue, setDebouncedValue] = useState(value);\r\n  \r\n  useEffect(() => {\r\n    const timer = setTimeout(() => {\r\n      setDebouncedValue(value);\r\n    }, delay);\r\n    \r\n    return () => clearTimeout(timer);\r\n  }, [value, delay]);\r\n  \r\n  return debouncedValue;\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 23,
    "category": "React ‚Äì Hooks Comparison (Most Asked in Interviews)",
    "title": "What is the difference between useEffect with empty deps vs no deps?",
    "content": "\r\n**`useEffect(() => {}, [])` - Empty dependency array:**\r\n- Runs **once** after initial render\r\n- Equivalent to `componentDidMount`\r\n- Use for: One-time setup, initial data fetching\r\n\r\n**`useEffect(() => {})` - No dependency array:**\r\n- Runs **after every render**\r\n- Equivalent to `componentDidMount` + `componentDidUpdate`\r\n- Usually **dangerous** - can cause infinite loops\r\n- Use rarely: When you need effect on every render\r\n\r\n**Complete Example:**\r\n```javascript\r\nfunction Component() {\r\n  const [count, setCount] = useState(0);\r\n  const [name, setName] = useState('John');\r\n  \r\n  // ‚úÖ Empty array: Runs once on mount\r\n  useEffect(() => {\r\n    console.log('Component mounted - fetching initial data');\r\n    fetch('/api/data').then(/* ... */);\r\n  }, []); // Runs once\r\n  \r\n  // ‚ö†Ô∏è No array: Runs on EVERY render (dangerous!)\r\n  useEffect(() => {\r\n    console.log('Rendered!'); // Logs on every state change\r\n    // WARNING: If you update state here, infinite loop!\r\n    // setCount(count + 1); // ‚ùå DON'T DO THIS!\r\n  }); // Runs every render\r\n  \r\n  // ‚úÖ With dependencies: Runs when deps change\r\n  useEffect(() => {\r\n    console.log('Count changed:', count);\r\n  }, [count]); // Only runs when count changes\r\n  \r\n  // ‚úÖ Multiple dependencies\r\n  useEffect(() => {\r\n    console.log('Count or name changed');\r\n  }, [count, name]); // Runs when count OR name changes\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\r\n      <button onClick={() => setName('Jane')}>Name: {name}</button>\r\n    </div>\r\n  );\r\n}\r\n\r\n// When to use each:\r\n// [] - Initial setup, subscriptions, timers\r\n// [deps] - Effect depends on specific values\r\n// No array - Rarely needed (logging, analytics)\r\n```\r\n\r\n\r"
  },
  {
    "id": 24,
    "category": "React ‚Äì Hooks Comparison (Most Asked in Interviews)",
    "title": "What is the difference between useRef and createRef?",
    "content": "\r\n**`useRef`:**\r\n- Hook (can only use in functional components)\r\n- Returns **same ref object** across renders\r\n- Value persists across re-renders\r\n- Use in: Functional components\r\n\r\n**`createRef`:**\r\n- Regular function (can use anywhere)\r\n- Returns **new ref object** on every render\r\n- Not suitable for functional components\r\n- Use in: Class components\r\n\r\n**Complete Example:**\r\n```javascript\r\n// ‚úÖ useRef in functional component\r\nfunction FunctionalComponent() {\r\n  const inputRef = useRef(null); // Same ref across renders\r\n  \r\n  useEffect(() => {\r\n    inputRef.current.focus();\r\n  }, []);\r\n  \r\n  return <input ref={inputRef} />;\r\n}\r\n\r\n// ‚úÖ createRef in class component\r\nclass ClassComponent extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.inputRef = createRef(); // Create ref in constructor\r\n  }\r\n  \r\n  componentDidMount() {\r\n    this.inputRef.current.focus();\r\n  }\r\n  \r\n  render() {\r\n    return <input ref={this.inputRef} />;\r\n  }\r\n}\r\n\r\n// ‚ùå createRef in functional component (wrong!)\r\nfunction WrongComponent() {\r\n  const inputRef = createRef(); // New ref on every render!\r\n  // This won't work correctly - ref is recreated each render\r\n  \r\n  return <input ref={inputRef} />;\r\n}\r\n\r\n// ‚úÖ useRef is the correct choice for functional components\r\n```\r\n\r\n\r"
  },
  {
    "id": 25,
    "category": "React ‚Äì Hooks Comparison (Most Asked in Interviews)",
    "title": "What is the difference between useState and useReducer for complex state?",
    "content": "\r\n**`useState`:**\r\n- Simple state updates\r\n- Direct value assignment\r\n- Best for: Single values, simple updates\r\n- Can become messy with complex state\r\n\r\n**`useReducer`:**\r\n- Complex state logic\r\n- Action-based updates\r\n- Best for: Multiple related values, complex logic\r\n- Cleaner for complex state\r\n\r\n**Complete Example:**\r\n```javascript\r\n// ‚ùå useState for complex state (gets messy)\r\nfunction Form() {\r\n  const [name, setName] = useState('');\r\n  const [email, setEmail] = useState('');\r\n  const [age, setAge] = useState('');\r\n  const [errors, setErrors] = useState({});\r\n  const [touched, setTouched] = useState({});\r\n  \r\n  const handleSubmit = () => {\r\n    // Complex validation logic...\r\n    if (!name) setErrors(prev => ({ ...prev, name: 'Required' }));\r\n    if (!email) setErrors(prev => ({ ...prev, email: 'Required' }));\r\n    // Gets complicated with many fields\r\n  };\r\n  \r\n  // ... many handlers\r\n}\r\n\r\n// ‚úÖ useReducer for complex state (cleaner)\r\nconst initialState = {\r\n  name: '',\r\n  email: '',\r\n  age: '',\r\n  errors: {},\r\n  touched: {}\r\n};\r\n\r\nfunction formReducer(state, action) {\r\n  switch (action.type) {\r\n    case 'SET_FIELD':\r\n      return {\r\n        ...state,\r\n        [action.field]: action.value,\r\n        errors: { ...state.errors, [action.field]: null }\r\n      };\r\n    case 'SET_ERROR':\r\n      return {\r\n        ...state,\r\n        errors: { ...state.errors, [action.field]: action.error }\r\n      };\r\n    case 'TOUCH_FIELD':\r\n      return {\r\n        ...state,\r\n        touched: { ...state.touched, [action.field]: true }\r\n      };\r\n    case 'RESET':\r\n      return initialState;\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nfunction Form() {\r\n  const [state, dispatch] = useReducer(formReducer, initialState);\r\n  \r\n  const handleChange = (field, value) => {\r\n    dispatch({ type: 'SET_FIELD', field, value });\r\n  };\r\n  \r\n  const handleSubmit = () => {\r\n    // Validation logic\r\n    if (!state.name) {\r\n      dispatch({ type: 'SET_ERROR', field: 'name', error: 'Required' });\r\n    }\r\n  };\r\n  \r\n  return (\r\n    <form>\r\n      <input \r\n        value={state.name}\r\n        onChange={e => handleChange('name', e.target.value)}\r\n      />\r\n      {/* ... */}\r\n    </form>\r\n  );\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 26,
    "category": "React ‚Äì Hooks Comparison (Most Asked in Interviews)",
    "title": "What is the difference between useEffect cleanup and componentWillUnmount?",
    "content": "\r\n**`componentWillUnmount` (Class Components):**\r\n- Runs **once** when component unmounts\r\n- Only cleanup on unmount\r\n- Can't access latest props/state easily\r\n\r\n**`useEffect` Cleanup (Functional Components):**\r\n- Runs on **unmount AND before effect runs again**\r\n- More flexible - cleanup when dependencies change\r\n- Has access to latest values via closure\r\n\r\n**Complete Example:**\r\n```javascript\r\n// Class Component (old way)\r\nclass Timer extends React.Component {\r\n  componentDidMount() {\r\n    this.timer = setInterval(() => {\r\n      console.log('Tick');\r\n    }, 1000);\r\n  }\r\n  \r\n  componentWillUnmount() {\r\n    clearInterval(this.timer); // Only runs on unmount\r\n  }\r\n  \r\n  render() {\r\n    return <div>Timer</div>;\r\n  }\r\n}\r\n\r\n// Functional Component (modern way)\r\nfunction Timer() {\r\n  useEffect(() => {\r\n    const timer = setInterval(() => {\r\n      console.log('Tick');\r\n    }, 1000);\r\n    \r\n    // Cleanup runs:\r\n    // 1. When component unmounts\r\n    // 2. Before effect runs again (if deps change)\r\n    return () => {\r\n      clearInterval(timer);\r\n    };\r\n  }, []); // Empty deps = cleanup only on unmount\r\n  \r\n  return <div>Timer</div>;\r\n}\r\n\r\n// Cleanup with dependencies\r\nfunction UserProfile({ userId }) {\r\n  useEffect(() => {\r\n    const controller = new AbortController();\r\n    \r\n    fetch(`/api/users/${userId}`, { signal: controller.signal })\r\n      .then(/* ... */);\r\n    \r\n    // Cleanup runs:\r\n    // 1. When userId changes (cancels old request)\r\n    // 2. When component unmounts\r\n    return () => {\r\n      controller.abort(); // Cancel request\r\n    };\r\n  }, [userId]); // Cleanup when userId changes\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 27,
    "category": "React ‚Äì Hooks Comparison (Most Asked in Interviews)",
    "title": "What is the difference between useMemo and direct calculation?",
    "content": "\r\n**Direct Calculation:**\r\n- Calculates on **every render**\r\n- Simple and straightforward\r\n- No overhead\r\n- Use for: Simple calculations\r\n\r\n**`useMemo`:**\r\n- Calculates **only when dependencies change**\r\n- Slight overhead (checking dependencies)\r\n- Use for: Expensive calculations\r\n\r\n**Complete Example:**\r\n```javascript\r\nfunction ProductList({ products }) {\r\n  const [filter, setFilter] = useState('');\r\n  \r\n  // ‚ùå Direct calculation: Runs on every render\r\n  const filteredProducts = products.filter(p => \r\n    p.name.toLowerCase().includes(filter.toLowerCase())\r\n  );\r\n  // Even if products and filter don't change, this runs every render\r\n  \r\n  // ‚úÖ useMemo: Only recalculates when products or filter change\r\n  const filteredProducts = useMemo(() => {\r\n    console.log('Filtering...'); // Only logs when deps change\r\n    return products.filter(p => \r\n      p.name.toLowerCase().includes(filter.toLowerCase())\r\n    );\r\n  }, [products, filter]);\r\n  \r\n  // When to use useMemo:\r\n  // ‚úÖ Expensive operations (large arrays, complex calculations)\r\n  // ‚úÖ Preventing unnecessary re-renders\r\n  // ‚ùå Simple calculations (a + b, string concatenation)\r\n  \r\n  return (\r\n    <div>\r\n      <input value={filter} onChange={e => setFilter(e.target.value)} />\r\n      {filteredProducts.map(p => <Product key={p.id} product={p} />)}\r\n    </div>\r\n  );\r\n}\r\n\r\n// Simple calculation - don't use useMemo\r\nfunction SimpleComponent({ a, b }) {\r\n  const sum = a + b; // ‚úÖ Simple, no need for useMemo\r\n  // const sum = useMemo(() => a + b, [a, b]); // ‚ùå Overhead not worth it\r\n}\r\n```\r\n\r\n\r\n"
  },
  {
    "id": 28,
    "category": "React ‚Äì State Management",
    "title": "When should state be local vs global?",
    "content": "\r\n**Local State (useState in component):**\r\n- **UI state:** Form inputs, modals, dropdowns\r\n- **Component-specific:** Data only used within that component\r\n- **Temporary:** Data that doesn't need to persist\r\n- **Simple cases:** When prop drilling isn't a problem\r\n\r\n**Global State (Context, Redux, Zustand):**\r\n- **Shared data:** User info, theme, language\r\n- **Cross-component:** Data needed by many unrelated components\r\n- **Persistent:** Data that should survive component unmounts\r\n- **Complex state:** When prop drilling becomes unwieldy\r\n\r\n**Rule of thumb:** Start local, lift up when needed, go global only when necessary.\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// ‚úÖ Local State: Form input (only used in this component)\r\nfunction LoginForm() {\r\n  const [email, setEmail] = useState(''); // Local - only this form needs it\r\n  const [password, setPassword] = useState(''); // Local\r\n  \r\n  return (\r\n    <form>\r\n      <input value={email} onChange={e => setEmail(e.target.value)} />\r\n      <input value={password} onChange={e => setPassword(e.target.value)} />\r\n    </form>\r\n  );\r\n}\r\n\r\n// ‚úÖ Lifted State: Shared between siblings\r\nfunction TodoApp() {\r\n  const [todos, setTodos] = useState([]); // Lifted to parent\r\n  \r\n  return (\r\n    <div>\r\n      <TodoInput onAdd={todo => setTodos([...todos, todo])} />\r\n      <TodoList todos={todos} />\r\n    </div>\r\n  );\r\n}\r\n\r\n// ‚úÖ Global State: User authentication (needed everywhere)\r\nconst AuthContext = createContext();\r\n\r\nfunction App() {\r\n  const [user, setUser] = useState(null); // Global - many components need this\r\n  \r\n  return (\r\n    <AuthContext.Provider value={{ user, setUser }}>\r\n      <Header /> {/* Needs user */}\r\n      <Profile /> {/* Needs user */}\r\n      <Settings /> {/* Needs user */}\r\n    </AuthContext.Provider>\r\n  );\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 29,
    "category": "React ‚Äì State Management",
    "title": "What is lifting state up?",
    "content": "\r\n**Lifting state up:**\r\n- Moving state from a child component to a common parent\r\n- Allows sharing state between sibling components\r\n- Parent manages state and passes it down as props\r\n\r\n**When to use:**\r\n- Multiple components need the same data\r\n- Sibling components need to communicate\r\n- State needs to be synchronized\r\n\r\n**Complete Example:**\r\n\r\n```javascript\r\n// ‚ùå Before: State in child (can't share with sibling)\r\nfunction Counter1() {\r\n  const [count, setCount] = useState(0);\r\n  return (\r\n    <div>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n      <p>Count: {count}</p>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Counter2() {\r\n  // Can't see count from Counter1!\r\n  return <p>I don't know the count</p>;\r\n}\r\n\r\n// ‚úÖ After: State lifted to parent (can share with siblings)\r\nfunction App() {\r\n  const [count, setCount] = useState(0); // State in parent\r\n  \r\n  return (\r\n    <div>\r\n      <CounterDisplay count={count} /> {/* Shows count */}\r\n      <CounterButton count={count} setCount={setCount} /> {/* Updates count */}\r\n      <CounterInfo count={count} /> {/* Also shows count */}\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction CounterDisplay({ count }) {\r\n  return <h1>Count: {count}</h1>; // Receives count as prop\r\n}\r\n\r\nfunction CounterButton({ count, setCount }) {\r\n  return (\r\n    <button onClick={() => setCount(count + 1)}>\r\n      Increment (Current: {count})\r\n    </button>\r\n  );\r\n}\r\n\r\nfunction CounterInfo({ count }) {\r\n  return <p>You've clicked {count} times</p>; // Also receives count\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 30,
    "category": "React ‚Äì State Management",
    "title": "How do you share data between unrelated components?",
    "content": "\r\n**Options:**\r\n\r\n1. **Context API:**\r\n   - Best for app-wide data (theme, auth, language)\r\n   - Built into React\r\n   - Good for moderate complexity\r\n\r\n2. **State management library:**\r\n   - **Redux:** Complex state, time-travel debugging\r\n   - **Zustand:** Simpler, lightweight\r\n   - **Recoil:** Facebook's atomic state management\r\n\r\n3. **Lift state up:**\r\n   - Move to common ancestor\r\n   - Works if components share a parent\r\n\r\n4. **Event system:**\r\n   - Custom event emitters\r\n   - Usually not recommended (hard to track)\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// Example 1: Context API (for app-wide data)\r\nconst UserContext = createContext();\r\n\r\nfunction App() {\r\n  const [user, setUser] = useState({ name: 'John', role: 'admin' });\r\n  \r\n  return (\r\n    <UserContext.Provider value={{ user, setUser }}>\r\n      <Header />      {/* Unrelated to Sidebar */}\r\n      <MainContent /> {/* Unrelated to Header */}\r\n      <Sidebar />     {/* Unrelated to MainContent */}\r\n    </UserContext.Provider>\r\n  );\r\n}\r\n\r\nfunction Header() {\r\n  const { user } = useContext(UserContext);\r\n  return <header>Welcome, {user.name}!</header>;\r\n}\r\n\r\nfunction Sidebar() {\r\n  const { user } = useContext(UserContext);\r\n  return <aside>Role: {user.role}</aside>;\r\n}\r\n\r\n// Example 2: Redux (for complex state management)\r\nimport { createStore } from 'redux';\r\n\r\nconst initialState = { count: 0 };\r\n\r\nfunction reducer(state = initialState, action) {\r\n  switch (action.type) {\r\n    case 'INCREMENT':\r\n      return { count: state.count + 1 };\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nconst store = createStore(reducer);\r\n\r\n// Example 3: Lift state up (when components share parent)\r\nfunction Parent() {\r\n  const [sharedData, setSharedData] = useState('Hello');\r\n  \r\n  return (\r\n    <div>\r\n      <ChildA data={sharedData} setData={setSharedData} />\r\n      <ChildB data={sharedData} />\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 31,
    "category": "React ‚Äì State Management",
    "title": "What is Redux and how does it work?",
    "content": "\r\n**Redux** is a predictable state management library for JavaScript applications, commonly used with React.\r\n\r\n**Core Concepts:**\r\n1. **Single Source of Truth:** All app state stored in one object (store)\r\n2. **State is Read-Only:** Can't modify state directly\r\n3. **Changes via Pure Functions:** Reducers handle state updates\r\n4. **Unidirectional Data Flow:** Predictable state updates\r\n\r\n**Redux Architecture:**\r\n```\r\nComponent ‚Üí Action ‚Üí Reducer ‚Üí Store ‚Üí Component (re-renders)\r\n```\r\n\r\n**Key Parts:**\r\n- **Store:** Single object holding entire app state\r\n- **Actions:** Plain objects describing what happened\r\n- **Reducers:** Pure functions that update state\r\n- **Dispatch:** Function to send actions to store\r\n\r\n**When to use Redux:**\r\n- ‚úÖ Complex state logic\r\n- ‚úÖ State needed by many components\r\n- ‚úÖ Time-travel debugging needed\r\n- ‚úÖ Large applications\r\n- ‚ùå Simple apps (use Context API instead)\r\n- ‚ùå Small state (use useState instead)\r\n\r\n**Complete Example (Redux Toolkit - Modern Way):**\r\n\r\n```javascript\r\n// Step 1: Install Redux Toolkit\r\n// npm install @reduxjs/toolkit react-redux\r\n\r\n// Step 2: Create a slice (reducer + actions)\r\nimport { createSlice } from '@reduxjs/toolkit';\r\n\r\nconst counterSlice = createSlice({\r\n  name: 'counter',\r\n  initialState: { value: 0 },\r\n  reducers: {\r\n    increment: (state) => {\r\n      state.value += 1; // Redux Toolkit uses Immer (can mutate)\r\n    },\r\n    decrement: (state) => {\r\n      state.value -= 1;\r\n    },\r\n    incrementByAmount: (state, action) => {\r\n      state.value += action.payload;\r\n    },\r\n    reset: (state) => {\r\n      state.value = 0;\r\n    }\r\n  }\r\n});\r\n\r\n// Export actions (automatically generated)\r\nexport const { increment, decrement, incrementByAmount, reset } = counterSlice.actions;\r\n\r\n// Export reducer\r\nexport default counterSlice.reducer;\r\n\r\n// Step 3: Create store\r\nimport { configureStore } from '@reduxjs/toolkit';\r\nimport counterReducer from './counterSlice';\r\n\r\nconst store = configureStore({\r\n  reducer: {\r\n    counter: counterReducer,\r\n    // Add more reducers here\r\n  }\r\n});\r\n\r\nexport default store;\r\n\r\n// Step 4: Provide store to app\r\nimport { Provider } from 'react-redux';\r\nimport store from './store';\r\n\r\nfunction App() {\r\n  return (\r\n    <Provider store={store}>\r\n      <CounterApp />\r\n    </Provider>\r\n  );\r\n}\r\n\r\n// Step 5: Use Redux in components\r\nimport { useSelector, useDispatch } from 'react-redux';\r\nimport { increment, decrement, incrementByAmount, reset } from './counterSlice';\r\n\r\nfunction Counter() {\r\n  // Get state from store\r\n  const count = useSelector((state) => state.counter.value);\r\n  \r\n  // Get dispatch function\r\n  const dispatch = useDispatch();\r\n  \r\n  return (\r\n    <div>\r\n      <h1>Count: {count}</h1>\r\n      <button onClick={() => dispatch(increment())}>+</button>\r\n      <button onClick={() => dispatch(decrement())}>-</button>\r\n      <button onClick={() => dispatch(incrementByAmount(5))}>+5</button>\r\n      <button onClick={() => dispatch(reset())}>Reset</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n**Complete Example (Traditional Redux - Understanding the Basics):**\r\n\r\n```javascript\r\n// Step 1: Define Action Types (constants)\r\nconst INCREMENT = 'INCREMENT';\r\nconst DECREMENT = 'DECREMENT';\r\nconst ADD_TODO = 'ADD_TODO';\r\nconst TOGGLE_TODO = 'TOGGLE_TODO';\r\n\r\n// Step 2: Create Action Creators (functions that return actions)\r\nfunction increment() {\r\n  return { type: INCREMENT };\r\n}\r\n\r\nfunction decrement() {\r\n  return { type: DECREMENT };\r\n}\r\n\r\nfunction addTodo(text) {\r\n  return {\r\n    type: ADD_TODO,\r\n    payload: { id: Date.now(), text, completed: false }\r\n  };\r\n}\r\n\r\nfunction toggleTodo(id) {\r\n  return { type: TOGGLE_TODO, payload: id };\r\n}\r\n\r\n// Step 3: Create Reducer (pure function)\r\nconst initialState = {\r\n  count: 0,\r\n  todos: []\r\n};\r\n\r\nfunction rootReducer(state = initialState, action) {\r\n  switch (action.type) {\r\n    case INCREMENT:\r\n      return { ...state, count: state.count + 1 };\r\n    \r\n    case DECREMENT:\r\n      return { ...state, count: state.count - 1 };\r\n    \r\n    case ADD_TODO:\r\n      return {\r\n        ...state,\r\n        todos: [...state.todos, action.payload]\r\n      };\r\n    \r\n    case TOGGLE_TODO:\r\n      return {\r\n        ...state,\r\n        todos: state.todos.map(todo =>\r\n          todo.id === action.payload\r\n            ? { ...todo, completed: !todo.completed }\r\n            : todo\r\n        )\r\n      };\r\n    \r\n    default:\r\n      return state; // Always return state if action doesn't match\r\n  }\r\n}\r\n\r\n// Step 4: Create Store\r\nimport { createStore } from 'redux';\r\nconst store = createStore(rootReducer);\r\n\r\n// Step 5: Use in React\r\nimport { Provider, useSelector, useDispatch } from 'react-redux';\r\n\r\nfunction App() {\r\n  return (\r\n    <Provider store={store}>\r\n      <Counter />\r\n      <TodoList />\r\n    </Provider>\r\n  );\r\n}\r\n\r\nfunction Counter() {\r\n  const count = useSelector(state => state.count);\r\n  const dispatch = useDispatch();\r\n  \r\n  return (\r\n    <div>\r\n      <p>Count: {count}</p>\r\n      <button onClick={() => dispatch(increment())}>+</button>\r\n      <button onClick={() => dispatch(decrement())}>-</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction TodoList() {\r\n  const todos = useSelector(state => state.todos);\r\n  const dispatch = useDispatch();\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => dispatch(addTodo('Learn Redux'))}>\r\n        Add Todo\r\n      </button>\r\n      <ul>\r\n        {todos.map(todo => (\r\n          <li\r\n            key={todo.id}\r\n            onClick={() => dispatch(toggleTodo(todo.id))}\r\n            style={{\r\n              textDecoration: todo.completed ? 'line-through' : 'none'\r\n            }}\r\n          >\r\n            {todo.text}\r\n          </li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n**Redux Flow Explained:**\r\n\r\n```\r\n1. User clicks button\r\n   ‚Üì\r\n2. Component calls dispatch(action)\r\n   ‚Üì\r\n3. Action sent to store\r\n   ‚Üì\r\n4. Store calls reducer with (currentState, action)\r\n   ‚Üì\r\n5. Reducer returns new state (immutable update)\r\n   ‚Üì\r\n6. Store updates with new state\r\n   ‚Üì\r\n7. Components subscribed to store re-render\r\n   ‚Üì\r\n8. UI updates with new state\r\n```\r\n\r\n**Key Redux Rules:**\r\n1. **State is Immutable:** Never mutate state directly\r\n   ```javascript\r\n   // ‚ùå Wrong\r\n   state.count += 1;\r\n   \r\n   // ‚úÖ Right\r\n   return { ...state, count: state.count + 1 };\r\n   ```\r\n\r\n2. **Reducers are Pure Functions:**\r\n   - No side effects (API calls, etc.)\r\n   - Same input = same output\r\n   - Don't mutate arguments\r\n\r\n3. **Actions are Plain Objects:**\r\n   ```javascript\r\n   { type: 'INCREMENT' }\r\n   { type: 'ADD_TODO', payload: { text: 'Learn Redux' } }\r\n   ```\r\n\r\n**Redux vs Context API:**\r\n\r\n| Feature | Redux | Context API |\r\n|---------|-------|-------------|\r\n| **Complexity** | More boilerplate | Simpler |\r\n| **Performance** | Optimized subscriptions | Can cause unnecessary re-renders |\r\n| **DevTools** | Excellent (time-travel) | Basic |\r\n| **Learning Curve** | Steeper | Easier |\r\n| **Use Case** | Large apps, complex state | Small-medium apps |\r\n| **Middleware** | Yes (thunk, saga) | No |\r\n\r\n**When to Choose Redux:**\r\n- ‚úÖ Large application with complex state\r\n- ‚úÖ Need time-travel debugging\r\n- ‚úÖ Multiple developers working on state\r\n- ‚úÖ Need middleware (API calls, logging)\r\n- ‚úÖ State logic is complex\r\n\r\n**When NOT to Use Redux:**\r\n- ‚ùå Small applications\r\n- ‚ùå Simple state management\r\n- ‚ùå Learning React (start with useState/Context)\r\n- ‚ùå Over-engineering simple problems\r\n\r\n**Redux Middleware Example (Redux Thunk for Async):**\r\n\r\n```javascript\r\nimport { createAsyncThunk } from '@reduxjs/toolkit';\r\n\r\n// Async action with Redux Toolkit\r\nexport const fetchUser = createAsyncThunk(\r\n  'user/fetchUser',\r\n  async (userId) => {\r\n    const response = await fetch(`/api/users/${userId}`);\r\n    return response.json();\r\n  }\r\n);\r\n\r\n// In slice\r\nconst userSlice = createSlice({\r\n  name: 'user',\r\n  initialState: { user: null, loading: false, error: null },\r\n  reducers: {},\r\n  extraReducers: (builder) => {\r\n    builder\r\n      .addCase(fetchUser.pending, (state) => {\r\n        state.loading = true;\r\n      })\r\n      .addCase(fetchUser.fulfilled, (state, action) => {\r\n        state.loading = false;\r\n        state.user = action.payload;\r\n      })\r\n      .addCase(fetchUser.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.error.message;\r\n      });\r\n  }\r\n});\r\n\r\n// Use in component\r\nfunction UserProfile({ userId }) {\r\n  const dispatch = useDispatch();\r\n  const { user, loading, error } = useSelector(state => state.user);\r\n  \r\n  useEffect(() => {\r\n    dispatch(fetchUser(userId));\r\n  }, [userId, dispatch]);\r\n  \r\n  if (loading) return <div>Loading...</div>;\r\n  if (error) return <div>Error: {error}</div>;\r\n  return <div>{user?.name}</div>;\r\n}\r\n```\r\n\r\n**Summary:**\r\n- Redux = Predictable state container\r\n- Store = Single source of truth\r\n- Actions = What happened\r\n- Reducers = How state updates\r\n- Dispatch = Send actions\r\n- Use for complex state, avoid for simple apps\r\n\r\n\r\n"
  },
  {
    "id": 32,
    "category": "React ‚Äì Performance",
    "title": "How can you prevent unnecessary re-renders?",
    "content": "\r\n**Strategies:**\r\n\r\n1. **React.memo:**\r\n   - Memoize functional components\r\n   - Prevents re-render if props haven't changed\r\n\r\n2. **useMemo:**\r\n   - Memoize expensive computations\r\n   - Cache derived values\r\n\r\n3. **useCallback:**\r\n   - Memoize functions\r\n   - Prevent function recreation\r\n\r\n4. **Split components:**\r\n   - Isolate frequently changing state\r\n   - Keep stable parts separate\r\n\r\n5. **Code splitting:**\r\n   - Lazy load components\r\n   - Reduce initial bundle size\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// Example 1: React.memo\r\nconst ExpensiveChild = React.memo(({ name, count }) => {\r\n  console.log('Child rendered'); // Only logs when props change\r\n  return (\r\n    <div>\r\n      <p>Name: {name}</p>\r\n      <p>Count: {count}</p>\r\n    </div>\r\n  );\r\n});\r\n\r\nfunction Parent() {\r\n  const [count, setCount] = useState(0);\r\n  const [name, setName] = useState('John');\r\n  const [other, setOther] = useState(0);\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\r\n      <button onClick={() => setName('Jane')}>Change Name</button>\r\n      <button onClick={() => setOther(other + 1)}>Other: {other}</button>\r\n      \r\n      {/* Child only re-renders when name or count changes, not when other changes */}\r\n      <ExpensiveChild name={name} count={count} />\r\n    </div>\r\n  );\r\n}\r\n\r\n// Example 2: useMemo + useCallback together\r\nfunction ProductList({ products, filter }) {\r\n  const [sortOrder, setSortOrder] = useState('asc');\r\n  \r\n  // Memoize filtered products\r\n  const filteredProducts = useMemo(() => {\r\n    return products.filter(p => p.category === filter);\r\n  }, [products, filter]);\r\n  \r\n  // Memoize sort function\r\n  const handleSort = useCallback(() => {\r\n    setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');\r\n  }, [sortOrder]);\r\n  \r\n  return (\r\n    <div>\r\n      <button onClick={handleSort}>Sort: {sortOrder}</button>\r\n      {filteredProducts.map(product => (\r\n        <Product key={product.id} product={product} />\r\n      ))}\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 33,
    "category": "React ‚Äì Performance",
    "title": "What happens if keys are not unique?",
    "content": "\r\n**Problems:**\r\n\r\n1. **Incorrect updates:**\r\n   - React may update wrong components\r\n   - State can be mixed between components\r\n\r\n2. **Performance issues:**\r\n   - React can't efficiently track changes\r\n   - May re-render more than necessary\r\n\r\n3. **Bugs:**\r\n   - Form inputs may retain wrong values\r\n   - Component state may persist incorrectly\r\n\r\n4. **Console warnings:**\r\n   - React warns about duplicate keys\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// ‚ùå Bad: Duplicate keys\r\nfunction BadList({ items }) {\r\n  return (\r\n    <ul>\r\n      {items.map(item => (\r\n        <li key=\"same-key\"> {/* All items have same key! */}\r\n          {item.name}\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  );\r\n  // React warning: \"Encountered two children with the same key\"\r\n  // Problems:\r\n  // - React can't track which item changed\r\n  // - State may be mixed between items\r\n  // - Performance issues\r\n}\r\n\r\n// ‚úÖ Good: Unique keys from data\r\nfunction GoodList({ items }) {\r\n  return (\r\n    <ul>\r\n      {items.map(item => (\r\n        <li key={item.id}> {/* Unique ID from data */}\r\n          {item.name}\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  );\r\n}\r\n\r\n// ‚ö†Ô∏è Sometimes OK: Index as key (only if list never reorders)\r\nfunction StaticList({ items }) {\r\n  return (\r\n    <ul>\r\n      {items.map((item, index) => (\r\n        <li key={index}> {/* OK if list is static */}\r\n          {item.name}\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  );\r\n}\r\n\r\n// ‚ùå Bad: Index as key with reordering\r\nfunction SortableList({ items }) {\r\n  const [sorted, setSorted] = useState(items);\r\n  \r\n  return (\r\n    <ul>\r\n      {sorted.map((item, index) => (\r\n        <li key={index}> {/* BAD! Keys change when list reorders */}\r\n          <input defaultValue={item.name} /> {/* Input values get mixed up! */}\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  );\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 34,
    "category": "React ‚Äì Performance",
    "title": "How does React know what to update?",
    "content": "\r\n**Reconciliation process:**\r\n\r\n1. **Virtual DOM diffing:**\r\n   - React compares new virtual DOM tree with previous one\r\n   - Uses efficient diffing algorithm\r\n\r\n2. **Key-based reconciliation:**\r\n   - Keys help identify which items changed\r\n   - React matches elements by key\r\n\r\n3. **Component type comparison:**\r\n   - If component type changes, React unmounts old and mounts new\r\n   - If same type, React updates props and re-renders\r\n\r\n4. **Batching:**\r\n   - Multiple state updates are batched\r\n   - Single DOM update for multiple changes\r\n\r\n5. **Fiber architecture:**\r\n   - React Fiber allows incremental rendering\r\n   - Can pause, abort, or prioritize work\r\n\r\n**Result:** Only changed parts of the DOM are updated, not the entire tree.\r\n\r\n**Complete Example:**\r\n\r\n```javascript\r\nfunction App() {\r\n  const [count, setCount] = useState(0);\r\n  const [name, setName] = useState('John');\r\n  \r\n  return (\r\n    <div>\r\n      <Header name={name} />\r\n      <Counter count={count} />\r\n      <Footer />\r\n    </div>\r\n  );\r\n}\r\n\r\n// When count changes:\r\n// 1. React creates new Virtual DOM tree\r\n// 2. Compares with previous Virtual DOM\r\n// 3. Finds: Only <Counter> component changed\r\n// 4. Updates: Only Counter component in real DOM\r\n// 5. Header and Footer stay unchanged (no re-render needed)\r\n\r\n// Example with keys:\r\nfunction TodoList({ todos }) {\r\n  return (\r\n    <ul>\r\n      {todos.map(todo => (\r\n        <TodoItem key={todo.id} todo={todo} />\r\n        // Key helps React identify which item changed\r\n        // If todo with id=3 changes, React knows to update only that item\r\n      ))}\r\n    </ul>\r\n  );\r\n}\r\n\r\n// Batching example:\r\nfunction Component() {\r\n  const [a, setA] = useState(0);\r\n  const [b, setB] = useState(0);\r\n  \r\n  const handleClick = () => {\r\n    setA(1); // State update 1\r\n    setB(2); // State update 2\r\n    // React batches these into ONE re-render!\r\n    // Virtual DOM updated once, real DOM updated once\r\n  };\r\n}\r\n```\r\n\r\n\r\n"
  },
  {
    "id": 35,
    "category": "React ‚Äì Working with Backend",
    "title": "How do you make an API call in React?",
    "content": "\r\n**Methods:**\r\n\r\n1. **Fetch API:**\r\n   ```javascript\r\n   useEffect(() => {\r\n     fetch('/api/data')\r\n       .then(res => res.json())\r\n       .then(data => setData(data));\r\n   }, []);\r\n   ```\r\n\r\n2. **Axios:**\r\n   ```javascript\r\n   useEffect(() => {\r\n     axios.get('/api/data')\r\n       .then(res => setData(res.data));\r\n   }, []);\r\n   ```\r\n\r\n3. **Async/await:**\r\n   ```javascript\r\n   useEffect(() => {\r\n     async function fetchData() {\r\n       const res = await fetch('/api/data');\r\n       const data = await res.json();\r\n       setData(data);\r\n     }\r\n     fetchData();\r\n   }, []);\r\n   ```\r\n\r\n4. **Libraries:**\r\n   - **React Query:** Caching, refetching, mutations\r\n   - **SWR:** Data fetching with caching\r\n   - **Apollo Client:** For GraphQL\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// Example 1: Fetch API with useEffect\r\nfunction UserList() {\r\n  const [users, setUsers] = useState([]);\r\n  const [loading, setLoading] = useState(true);\r\n  \r\n  useEffect(() => {\r\n    fetch('/api/users')\r\n      .then(res => res.json())\r\n      .then(data => {\r\n        setUsers(data);\r\n        setLoading(false);\r\n      })\r\n      .catch(err => {\r\n        console.error(err);\r\n        setLoading(false);\r\n      });\r\n  }, []);\r\n  \r\n  if (loading) return <div>Loading...</div>;\r\n  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;\r\n}\r\n\r\n// Example 2: Axios with async/await\r\nimport axios from 'axios';\r\n\r\nfunction UserProfile({ userId }) {\r\n  const [user, setUser] = useState(null);\r\n  \r\n  useEffect(() => {\r\n    async function fetchUser() {\r\n      try {\r\n        const res = await axios.get(`/api/users/${userId}`);\r\n        setUser(res.data);\r\n      } catch (err) {\r\n        console.error('Error:', err);\r\n      }\r\n    }\r\n    fetchUser();\r\n  }, [userId]);\r\n  \r\n  return user ? <div>{user.name}</div> : <div>Loading...</div>;\r\n}\r\n\r\n// Example 3: React Query (recommended for production)\r\nimport { useQuery } from 'react-query';\r\n\r\nfunction UserProfile({ userId }) {\r\n  const { data: user, isLoading, error } = useQuery(\r\n    ['user', userId],\r\n    () => fetch(`/api/users/${userId}`).then(res => res.json())\r\n  );\r\n  \r\n  if (isLoading) return <div>Loading...</div>;\r\n  if (error) return <div>Error: {error.message}</div>;\r\n  return <div>{user.name}</div>;\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 36,
    "category": "React ‚Äì Working with Backend",
    "title": "Where should fetch / axios calls be placed?",
    "content": "\r\n**Best practices:**\r\n\r\n1. **useEffect hook:**\r\n   - For data fetching on component mount\r\n   - Most common approach\r\n\r\n2. **Event handlers:**\r\n   - For user-triggered API calls (form submit, button click)\r\n\r\n3. **Custom hooks:**\r\n   - Extract API logic into reusable hooks\r\n   - Better organization and reusability\r\n\r\n4. **Service layer:**\r\n   - Separate API functions in service files\r\n   - Keep components clean\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// ‚úÖ Best Practice: Custom hook + Service layer\r\n\r\n// 1. Service file (api/userService.js)\r\nexport async function fetchUser(id) {\r\n  const res = await fetch(`/api/users/${id}`);\r\n  if (!res.ok) throw new Error('Failed to fetch user');\r\n  return res.json();\r\n}\r\n\r\nexport async function createUser(userData) {\r\n  const res = await fetch('/api/users', {\r\n    method: 'POST',\r\n    headers: { 'Content-Type': 'application/json' },\r\n    body: JSON.stringify(userData)\r\n  });\r\n  if (!res.ok) throw new Error('Failed to create user');\r\n  return res.json();\r\n}\r\n\r\n// 2. Custom hook (hooks/useUser.js)\r\nfunction useUser(userId) {\r\n  const [user, setUser] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n  \r\n  useEffect(() => {\r\n    async function loadUser() {\r\n      try {\r\n        setLoading(true);\r\n        const data = await fetchUser(userId);\r\n        setUser(data);\r\n      } catch (err) {\r\n        setError(err.message);\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    }\r\n    loadUser();\r\n  }, [userId]);\r\n  \r\n  return { user, loading, error };\r\n}\r\n\r\n// 3. Component (clean and simple)\r\nfunction UserProfile({ userId }) {\r\n  const { user, loading, error } = useUser(userId);\r\n  \r\n  if (loading) return <div>Loading...</div>;\r\n  if (error) return <div>Error: {error}</div>;\r\n  return <div>{user.name}</div>;\r\n}\r\n\r\n// ‚úÖ Event handler (user-triggered)\r\nfunction CreateUserForm() {\r\n  const [name, setName] = useState('');\r\n  \r\n  const handleSubmit = async (e) => {\r\n    e.preventDefault();\r\n    try {\r\n      await createUser({ name });\r\n      alert('User created!');\r\n    } catch (err) {\r\n      alert('Error: ' + err.message);\r\n    }\r\n  };\r\n  \r\n  return (\r\n    <form onSubmit={handleSubmit}>\r\n      <input value={name} onChange={e => setName(e.target.value)} />\r\n      <button type=\"submit\">Create User</button>\r\n    </form>\r\n  );\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 37,
    "category": "React ‚Äì Working with Backend",
    "title": "How do you handle loading and error states?",
    "content": "\r\n**Pattern:**\r\n\r\n```javascript\r\nfunction DataComponent() {\r\n  const [data, setData] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n\r\n  useEffect(() => {\r\n    async function fetchData() {\r\n      try {\r\n        setLoading(true);\r\n        const res = await fetch('/api/data');\r\n        if (!res.ok) throw new Error('Failed to fetch');\r\n        const data = await res.json();\r\n        setData(data);\r\n      } catch (err) {\r\n        setError(err.message);\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    }\r\n    fetchData();\r\n  }, []);\r\n\r\n  if (loading) return <Spinner />;\r\n  if (error) return <Error message={error} />;\r\n  return <DataDisplay data={data} />;\r\n}\r\n```\r\n\r\n**Libraries:**\r\n- **React Query:** Built-in loading/error states\r\n- **SWR:** Automatic error handling\r\n\r\n**Complete Example with React Query:**\r\n\r\n```javascript\r\nimport { useQuery } from 'react-query';\r\n\r\nfunction UserProfile({ userId }) {\r\n  const { data: user, isLoading, error } = useQuery(\r\n    ['user', userId],\r\n    () => fetch(`/api/users/${userId}`).then(res => res.json()),\r\n    {\r\n      retry: 3, // Retry 3 times on failure\r\n      staleTime: 5000 // Consider data fresh for 5 seconds\r\n    }\r\n  );\r\n  \r\n  if (isLoading) return <div>Loading user...</div>;\r\n  if (error) return <div>Error: {error.message}</div>;\r\n  return <div>{user.name}</div>;\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 38,
    "category": "React ‚Äì Working with Backend",
    "title": "Where should authentication tokens be stored?",
    "content": "\r\n**Options:**\r\n\r\n1. **httpOnly cookies (Recommended for web):**\r\n   - Most secure, not accessible to JavaScript\r\n   - Protected from XSS attacks\r\n   - Sent automatically with requests\r\n\r\n2. **localStorage:**\r\n   - Accessible to JavaScript\r\n   - Vulnerable to XSS\r\n   - Persists across sessions\r\n   - **Not recommended for sensitive tokens**\r\n\r\n3. **sessionStorage:**\r\n   - Similar to localStorage\r\n   - Cleared when tab closes\r\n   - Still vulnerable to XSS\r\n\r\n4. **Memory (state):**\r\n   - Most secure (not persisted)\r\n   - Lost on refresh\r\n   - Good for temporary tokens\r\n\r\n**Best practice:** Use httpOnly cookies for refresh tokens, memory for access tokens (short-lived).\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// ‚úÖ Option 1: httpOnly Cookie (Most Secure)\r\n// Backend sets cookie\r\napp.post('/api/login', async (req, res) => {\r\n  const token = jwt.sign({ userId: user.id }, secret);\r\n  res.cookie('token', token, {\r\n    httpOnly: true, // Not accessible via JavaScript\r\n    secure: true,   // HTTPS only\r\n    sameSite: 'strict'\r\n  });\r\n  res.json({ success: true });\r\n});\r\n\r\n// Frontend: Cookie sent automatically with requests\r\nfetch('/api/protected', {\r\n  credentials: 'include' // Include cookies\r\n});\r\n\r\n// ‚úÖ Option 2: Memory (State) - Good for access tokens\r\nfunction App() {\r\n  const [token, setToken] = useState(null); // In memory\r\n  \r\n  const login = async (email, password) => {\r\n    const res = await fetch('/api/login', {\r\n      method: 'POST',\r\n      body: JSON.stringify({ email, password })\r\n    });\r\n    const { token } = await res.json();\r\n    setToken(token); // Stored in memory\r\n  };\r\n  \r\n  // Token lost on refresh, but more secure\r\n}\r\n\r\n// ‚ùå Option 3: localStorage (NOT Recommended)\r\nlocalStorage.setItem('token', token); // Vulnerable to XSS!\r\n```\r\n\r\n\r\n"
  },
  {
    "id": 39,
    "category": "Node.js ‚Äì Basics",
    "title": "What is Node.js?",
    "content": "\r\n**Node.js:**\r\n- A JavaScript **runtime** built on Chrome's V8 engine\r\n- Allows running JavaScript on the **server-side** (not just browser)\r\n- **Event-driven, non-blocking I/O** model\r\n- Built on Google's V8 JavaScript engine\r\n\r\n**Key features:**\r\n- Single-threaded event loop\r\n- Asynchronous I/O\r\n- NPM (Node Package Manager) ecosystem\r\n- Can build web servers, APIs, CLI tools, desktop apps\r\n\r\n**Use cases:**\r\n- Backend APIs and web servers\r\n- Real-time applications (chat, gaming)\r\n- Microservices\r\n- Build tools and automation\r\n\r\n**Complete Example:**\r\n\r\n```javascript\r\n// Simple Node.js server\r\nconst http = require('http');\r\n\r\nconst server = http.createServer((req, res) => {\r\n  if (req.url === '/api/users' && req.method === 'GET') {\r\n    res.writeHead(200, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify([{ id: 1, name: 'John' }]));\r\n  } else {\r\n    res.writeHead(404);\r\n    res.end('Not Found');\r\n  }\r\n});\r\n\r\nserver.listen(3000, () => {\r\n  console.log('Server running on http://localhost:3000');\r\n});\r\n\r\n// Run with: node server.js\r\n```\r\n\r\n\r"
  },
  {
    "id": 40,
    "category": "Node.js ‚Äì Basics",
    "title": "Why is Node.js single-threaded but still efficient?",
    "content": "\r\n**Single-threaded:**\r\n- Node.js uses a single main thread for JavaScript execution\r\n- No thread management overhead\r\n- Simpler programming model (no race conditions in JS code)\r\n\r\n**Still efficient because:**\r\n\r\n1. **Non-blocking I/O:**\r\n   - I/O operations don't block the thread\r\n   - Uses OS-level threads for I/O (via libuv)\r\n   - While waiting for I/O, thread handles other requests\r\n\r\n2. **Event loop:**\r\n   - Efficiently manages asynchronous operations\r\n   - Queues callbacks and executes them when ready\r\n\r\n3. **Worker threads (for CPU-intensive tasks):**\r\n   - Can spawn worker threads for heavy computations\r\n   - Main thread stays free for I/O\r\n\r\n**Best for:** I/O-intensive applications (APIs, databases, file operations)\r\n**Not ideal for:** CPU-intensive tasks (image processing, heavy calculations)\r\n\r\n**Complete Example:**\r\n\r\n```javascript\r\n// ‚úÖ Good: I/O-intensive (Node.js excels here)\r\napp.get('/api/users', async (req, res) => {\r\n  // Database query (I/O) - doesn't block!\r\n  const users = await db.query('SELECT * FROM users');\r\n  res.json(users);\r\n});\r\n\r\n// Multiple requests can be handled concurrently:\r\n// Request 1: Waiting for DB ‚Üí Request 2 handled ‚Üí Request 3 handled\r\n// Request 1: DB responds ‚Üí Request 1 continues\r\n\r\n// ‚ùå Bad: CPU-intensive (blocks event loop)\r\napp.get('/api/process', (req, res) => {\r\n  // Heavy calculation blocks everything!\r\n  let result = 0;\r\n  for (let i = 0; i < 10000000000; i++) {\r\n    result += i; // Blocks event loop, can't handle other requests\r\n  }\r\n  res.json({ result });\r\n});\r\n\r\n// ‚úÖ Solution: Use Worker Threads for CPU-intensive tasks\r\nconst { Worker } = require('worker_threads');\r\n\r\napp.get('/api/process', (req, res) => {\r\n  const worker = new Worker('./heavy-calculation.js');\r\n  worker.on('message', (result) => {\r\n    res.json({ result });\r\n  });\r\n});\r\n```\r\n\r\n\r"
  },
  {
    "id": 41,
    "category": "Node.js ‚Äì Basics",
    "title": "What is the event loop?",
    "content": "\r\n**Event loop:**\r\n- The mechanism that allows Node.js to perform non-blocking I/O operations\r\n- Continuously checks for completed async operations and executes their callbacks\r\n\r\n**Phases:**\r\n\r\n1. **Timers:** Execute `setTimeout` and `setInterval` callbacks\r\n2. **Pending callbacks:** Execute I/O callbacks deferred to next iteration\r\n3. **Idle, prepare:** Internal use\r\n4. **Poll:** Fetch new I/O events, execute I/O callbacks\r\n5. **Check:** Execute `setImmediate` callbacks\r\n6. **Close callbacks:** Execute close event callbacks (sockets, etc.)\r\n\r\n**How it works:**\r\n```\r\n1. Execute synchronous code\r\n2. Process microtasks (Promises)\r\n3. Process next event loop phase\r\n4. Repeat\r\n```\r\n\r\n**Key point:** The event loop allows Node.js to handle many concurrent operations with a single thread.\r\n\r\n**Complete Example:**\r\n\r\n```javascript\r\nconsole.log('1. Start');\r\n\r\n// Timer phase\r\nsetTimeout(() => {\r\n  console.log('4. setTimeout (timers phase)');\r\n}, 0);\r\n\r\n// Microtask (Promise) - runs before next phase\r\nPromise.resolve().then(() => {\r\n  console.log('3. Promise (microtask)');\r\n});\r\n\r\n// Immediate - check phase\r\nsetImmediate(() => {\r\n  console.log('5. setImmediate (check phase)');\r\n});\r\n\r\nconsole.log('2. End');\r\n\r\n// Output order:\r\n// 1. Start\r\n// 2. End\r\n// 3. Promise (microtask - highest priority)\r\n// 4. setTimeout (timers phase)\r\n// 5. setImmediate (check phase)\r\n\r\n// Real-world example:\r\napp.get('/api/data', async (req, res) => {\r\n  console.log('Request received'); // 1. Synchronous code\r\n  \r\n  // 2. I/O operation (non-blocking)\r\n  const data = await db.query('SELECT * FROM users');\r\n  // While waiting for DB, event loop handles other requests!\r\n  \r\n  // 3. I/O completes, callback queued\r\n  res.json(data); // 4. Response sent\r\n});\r\n```\r\n\r\n\r"
  },
  {
    "id": 42,
    "category": "Node.js ‚Äì Basics",
    "title": "What is the difference between Node.js and JavaScript in the browser?",
    "content": "\r\n| Aspect | Browser JavaScript | Node.js |\r\n|--------|-------------------|---------|\r\n| **Global object** | `window` | `global` |\r\n| **DOM access** | Yes (document, elements) | No DOM |\r\n| **File system** | No access | Full access (`fs` module) |\r\n| **Network requests** | `fetch`, `XMLHttpRequest` | `http`, `https` modules |\r\n| **Modules** | ES6 modules, script tags | CommonJS, ES6 modules |\r\n| **Purpose** | Client-side interactivity | Server-side applications |\r\n| **APIs** | Browser APIs (localStorage, etc.) | Node APIs (process, buffer, etc.) |\r\n\r\n**Similarities:**\r\n- Same JavaScript language\r\n- Same V8 engine (Chrome)\r\n- Can use same libraries (if compatible)\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// Browser JavaScript\r\n// ‚úÖ Available\r\nwindow.localStorage.setItem('key', 'value');\r\ndocument.getElementById('myDiv');\r\nwindow.location.href = 'https://example.com';\r\n\r\n// ‚ùå Not available\r\n// require('fs'); // Error: fs is not defined\r\n// process.env.NODE_ENV; // Error: process is not defined\r\n\r\n// Node.js\r\n// ‚úÖ Available\r\nconst fs = require('fs');\r\nfs.readFile('file.txt', (err, data) => {\r\n  console.log(data);\r\n});\r\nconsole.log(process.env.NODE_ENV);\r\n\r\n// ‚ùå Not available\r\n// document.getElementById('myDiv'); // Error: document is not defined\r\n// window.localStorage; // Error: window is not defined\r\n\r\n// ‚úÖ Works in both\r\nconst arr = [1, 2, 3];\r\narr.map(x => x * 2); // Same JavaScript!\r\n```\r\n\r\n\r\n"
  },
  {
    "id": 43,
    "category": "Express.js",
    "title": "What is middleware?",
    "content": "\r\n**Middleware:**\r\n- Functions that execute during the request-response cycle\r\n- Have access to `req`, `res`, and `next`\r\n- Can modify request/response, end the cycle, or call `next()`\r\n\r\n**Types:**\r\n\r\n1. **Application-level:** `app.use()`\r\n2. **Router-level:** `router.use()`\r\n3. **Error-handling:** 4 parameters `(err, req, res, next)`\r\n4. **Built-in:** `express.json()`, `express.static()`\r\n5. **Third-party:** `cors`, `helmet`, `morgan`\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// Example 1: Custom logging middleware\r\nfunction logger(req, res, next) {\r\n  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);\r\n  next(); // Must call next() to continue\r\n}\r\n\r\napp.use(logger); // Runs for all routes\r\n\r\n// Example 2: Authentication middleware\r\nfunction authenticate(req, res, next) {\r\n  const token = req.headers.authorization;\r\n  if (!token) {\r\n    return res.status(401).json({ error: 'No token provided' });\r\n  }\r\n  // Verify token...\r\n  req.user = decodedUser; // Add user to request\r\n  next();\r\n}\r\n\r\napp.get('/api/profile', authenticate, (req, res) => {\r\n  // req.user is available here\r\n  res.json({ user: req.user });\r\n});\r\n\r\n// Example 3: Built-in middleware\r\napp.use(express.json()); // Parse JSON bodies\r\napp.use(express.static('public')); // Serve static files\r\napp.use(cors()); // Enable CORS\r\n\r\n// Example 4: Error-handling middleware (4 parameters)\r\napp.use((err, req, res, next) => {\r\n  console.error(err.stack);\r\n  res.status(500).json({ error: 'Something went wrong!' });\r\n});\r\n```\r\n\r\n\r"
  },
  {
    "id": 44,
    "category": "Express.js",
    "title": "In what order do middlewares run?",
    "content": "\r\n**Order matters!** Middlewares execute in the order they are defined.\r\n\r\n**Flow:**\r\n1. Middlewares defined with `app.use()` run first\r\n2. Then route-specific middlewares\r\n3. Finally, route handler\r\n\r\n**Complete Example:**\r\n\r\n```javascript\r\n// Middleware execution order matters!\r\n\r\napp.use((req, res, next) => {\r\n  console.log('1. Global middleware - runs first');\r\n  next();\r\n});\r\n\r\napp.use('/api', (req, res, next) => {\r\n  console.log('2. /api middleware - runs for /api/* routes');\r\n  next();\r\n});\r\n\r\napp.get('/api/users', \r\n  (req, res, next) => {\r\n    console.log('3. Route-specific middleware');\r\n    next();\r\n  },\r\n  (req, res) => {\r\n    console.log('4. Route handler - runs last');\r\n    res.json({ users: [] });\r\n  }\r\n);\r\n\r\n// Request to GET /api/users:\r\n// Output:\r\n// 1. Global middleware - runs first\r\n// 2. /api middleware - runs for /api/* routes\r\n// 3. Route-specific middleware\r\n// 4. Route handler - runs last\r\n\r\n// ‚ö†Ô∏è If middleware doesn't call next(), chain stops:\r\napp.use((req, res, next) => {\r\n  res.send('Stopped here'); // Doesn't call next()\r\n  // No further middleware or routes execute!\r\n});\r\n```\r\n\r\n\r"
  },
  {
    "id": 45,
    "category": "Express.js",
    "title": "How do you handle errors in Express?",
    "content": "\r\n**Methods:**\r\n\r\n1. **Try-catch in async handlers:**\r\n   ```javascript\r\n   app.get('/api/data', async (req, res, next) => {\r\n     try {\r\n       const data = await fetchData();\r\n       res.json(data);\r\n     } catch (err) {\r\n       next(err); // Pass to error handler\r\n     }\r\n   });\r\n   ```\r\n\r\n2. **Error-handling middleware:**\r\n   ```javascript\r\n   app.use((err, req, res, next) => {\r\n     console.error(err.stack);\r\n     res.status(500).json({ error: 'Something went wrong!' });\r\n   });\r\n   ```\r\n\r\n3. **Async error wrapper:**\r\n   ```javascript\r\n   const asyncHandler = (fn) => (req, res, next) => {\r\n     Promise.resolve(fn(req, res, next)).catch(next);\r\n   };\r\n   \r\n   app.get('/api/data', asyncHandler(async (req, res) => {\r\n     const data = await fetchData();\r\n     res.json(data);\r\n   }));\r\n   ```\r\n\r\n**Note:** Error middleware must have 4 parameters `(err, req, res, next)`.\r\n\r\n**Complete Example:**\r\n\r\n```javascript\r\n// ‚úÖ Method 1: Try-catch in async handlers\r\napp.get('/api/users', async (req, res, next) => {\r\n  try {\r\n    const users = await db.query('SELECT * FROM users');\r\n    res.json(users);\r\n  } catch (err) {\r\n    next(err); // Pass error to error handler\r\n  }\r\n});\r\n\r\n// ‚úÖ Method 2: Error-handling middleware (must be last!)\r\napp.use((err, req, res, next) => {\r\n  console.error('Error:', err.stack);\r\n  res.status(err.status || 500).json({\r\n    error: process.env.NODE_ENV === 'production' \r\n      ? 'Internal server error' \r\n      : err.message\r\n  });\r\n});\r\n\r\n// ‚úÖ Method 3: Async error wrapper (reusable)\r\nconst asyncHandler = (fn) => (req, res, next) => {\r\n  Promise.resolve(fn(req, res, next)).catch(next);\r\n};\r\n\r\n// Use it:\r\napp.get('/api/users', asyncHandler(async (req, res) => {\r\n  const users = await db.query('SELECT * FROM users');\r\n  res.json(users);\r\n  // Errors automatically caught and passed to error handler!\r\n}));\r\n\r\n// ‚úÖ Method 4: Express 5+ (automatic async error handling)\r\n// In Express 5, async errors are automatically caught\r\n```\r\n\r\n\r"
  },
  {
    "id": 46,
    "category": "Express.js",
    "title": "What is the difference between app.use() and app.get()?",
    "content": "\r\n**`app.use()`:**\r\n- Matches **all HTTP methods** (GET, POST, PUT, etc.)\r\n- Can match **prefixes** of paths\r\n- Used for middleware, not route handlers\r\n- Executes for matching paths and all sub-paths\r\n\r\n**`app.get()`:**\r\n- Matches **only GET** requests\r\n- Matches **exact** paths (unless using patterns)\r\n- Used for route handlers\r\n- More specific\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// app.use() - matches all methods and path prefixes\r\napp.use('/api', (req, res, next) => {\r\n  console.log('Runs for:');\r\n  console.log('  GET /api');\r\n  console.log('  POST /api');\r\n  console.log('  GET /api/users');\r\n  console.log('  POST /api/users');\r\n  console.log('  GET /api/posts/123');\r\n  // All /api/* routes!\r\n  next();\r\n});\r\n\r\n// app.get() - matches only GET and exact path\r\napp.get('/api/users', (req, res) => {\r\n  // Only runs for: GET /api/users\r\n  // Does NOT run for: POST /api/users\r\n  // Does NOT run for: GET /api/users/123\r\n  res.json({ users: [] });\r\n});\r\n\r\n// Practical example:\r\napp.use(express.json()); // Middleware for all routes\r\napp.use('/api', authenticate); // Auth for all /api routes\r\napp.get('/api/users', getUsers); // Handler for GET /api/users\r\napp.post('/api/users', createUser); // Handler for POST /api/users\r\napp.get('/api/posts', getPosts); // Handler for GET /api/posts\r\n```\r\n\r\n\r"
  },
  {
    "id": 47,
    "category": "Express.js",
    "title": "How do you validate incoming requests?",
    "content": "\r\n**Methods:**\r\n\r\n1. **Manual validation:**\r\n   ```javascript\r\n   app.post('/api/users', (req, res) => {\r\n     const { email, password } = req.body;\r\n     if (!email || !password) {\r\n       return res.status(400).json({ error: 'Missing fields' });\r\n     }\r\n     // ...\r\n   });\r\n   ```\r\n\r\n2. **Validation libraries:**\r\n   - **Joi:** Schema-based validation\r\n   - **express-validator:** Middleware for validation\r\n   - **yup:** Schema validation\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// ‚úÖ Method 1: Manual validation\r\napp.post('/api/users', (req, res) => {\r\n  const { email, password, age } = req.body;\r\n  \r\n  // Validate email\r\n  if (!email || !email.includes('@')) {\r\n    return res.status(400).json({ error: 'Invalid email' });\r\n  }\r\n  \r\n  // Validate password\r\n  if (!password || password.length < 8) {\r\n    return res.status(400).json({ error: 'Password must be at least 8 characters' });\r\n  }\r\n  \r\n  // Validate age\r\n  if (age && (age < 0 || age > 120)) {\r\n    return res.status(400).json({ error: 'Invalid age' });\r\n  }\r\n  \r\n  // All valid, create user\r\n  // ...\r\n});\r\n\r\n// ‚úÖ Method 2: express-validator (recommended)\r\nconst { body, validationResult } = require('express-validator');\r\n\r\napp.post('/api/users',\r\n  body('email').isEmail().withMessage('Must be valid email'),\r\n  body('password').isLength({ min: 8 }).withMessage('Must be at least 8 characters'),\r\n  body('age').optional().isInt({ min: 0, max: 120 }),\r\n  (req, res) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    \r\n    // All valid, create user\r\n    createUser(req.body);\r\n    res.status(201).json({ message: 'User created' });\r\n  }\r\n);\r\n\r\n// ‚úÖ Method 3: Joi (schema validation)\r\nconst Joi = require('joi');\r\n\r\nconst userSchema = Joi.object({\r\n  email: Joi.string().email().required(),\r\n  password: Joi.string().min(8).required(),\r\n  age: Joi.number().min(0).max(120).optional()\r\n});\r\n\r\napp.post('/api/users', (req, res) => {\r\n  const { error, value } = userSchema.validate(req.body);\r\n  if (error) {\r\n    return res.status(400).json({ error: error.details[0].message });\r\n  }\r\n  // value is validated and sanitized\r\n  createUser(value);\r\n  res.status(201).json({ message: 'User created' });\r\n});\r\n```\r\n\r\n\r\n"
  },
  {
    "id": 48,
    "category": "REST API",
    "title": "What is REST?",
    "content": "\r\n**REST (Representational State Transfer):**\r\n- An architectural style for designing web services\r\n- Uses standard HTTP methods (GET, POST, PUT, DELETE, etc.)\r\n- Stateless communication\r\n- Resources identified by URLs\r\n\r\n**RESTful principles:**\r\n\r\n1. **Stateless:** Each request contains all information needed\r\n2. **Resource-based:** URLs represent resources (`/api/users/123`)\r\n3. **HTTP methods:** GET (read), POST (create), PUT (update), DELETE (remove)\r\n4. **Representations:** JSON, XML, etc.\r\n5. **Uniform interface:** Consistent API design\r\n\r\n**Complete Example:**\r\n\r\n```javascript\r\n// RESTful API design\r\nconst express = require('express');\r\nconst app = express();\r\napp.use(express.json());\r\n\r\n// GET /api/users - Get all users\r\napp.get('/api/users', (req, res) => {\r\n  const users = getAllUsers();\r\n  res.json(users);\r\n});\r\n\r\n// GET /api/users/123 - Get specific user\r\napp.get('/api/users/:id', (req, res) => {\r\n  const user = getUserById(req.params.id);\r\n  if (!user) return res.status(404).json({ error: 'User not found' });\r\n  res.json(user);\r\n});\r\n\r\n// POST /api/users - Create new user\r\napp.post('/api/users', (req, res) => {\r\n  const user = createUser(req.body);\r\n  res.status(201).json(user); // 201 Created\r\n});\r\n\r\n// PUT /api/users/123 - Update entire user\r\napp.put('/api/users/:id', (req, res) => {\r\n  const user = updateUser(req.params.id, req.body);\r\n  res.json(user);\r\n});\r\n\r\n// DELETE /api/users/123 - Delete user\r\napp.delete('/api/users/:id', (req, res) => {\r\n  deleteUser(req.params.id);\r\n  res.status(204).send(); // 204 No Content\r\n});\r\n\r\n// RESTful principles:\r\n// ‚úÖ Resource-based URLs: /api/users, /api/posts\r\n// ‚úÖ HTTP methods: GET, POST, PUT, DELETE\r\n// ‚úÖ Stateless: Each request contains all info needed\r\n// ‚úÖ JSON responses\r\n```\r\n\r\n\r"
  },
  {
    "id": 49,
    "category": "REST API",
    "title": "What is the difference between PUT and PATCH?",
    "content": "\r\n**PUT:**\r\n- **Full update:** Replaces entire resource\r\n- Must send all fields (even unchanged ones)\r\n- Idempotent (same request = same result)\r\n- If field missing, it may be set to null/undefined\r\n\r\n**PATCH:**\r\n- **Partial update:** Updates only specified fields\r\n- Send only fields to change\r\n- Idempotent\r\n- Other fields remain unchanged\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// PUT - Full update (replace entire resource)\r\napp.put('/api/users/:id', (req, res) => {\r\n  const { name, email, age } = req.body;\r\n  \r\n  // Must provide ALL fields (replaces entire user)\r\n  const user = {\r\n    id: req.params.id,\r\n    name,      // Required\r\n    email,     // Required\r\n    age        // Required\r\n  };\r\n  \r\n  updateUser(req.params.id, user);\r\n  res.json(user);\r\n});\r\n\r\n// Request:\r\n// PUT /api/users/123\r\n// Body: { \"name\": \"John\", \"email\": \"john@example.com\", \"age\": 30 }\r\n// Result: Entire user replaced\r\n\r\n// PATCH - Partial update (update only specified fields)\r\napp.patch('/api/users/:id', (req, res) => {\r\n  // Only update fields provided in request\r\n  const updates = req.body; // { name: \"Jane\" } or { age: 31 } or both\r\n  \r\n  const user = updateUserPartial(req.params.id, updates);\r\n  res.json(user);\r\n});\r\n\r\n// Request:\r\n// PATCH /api/users/123\r\n// Body: { \"name\": \"Jane\" }\r\n// Result: Only name updated, email and age unchanged\r\n\r\n// Real-world example:\r\n// PUT /api/users/123\r\n// { \"name\": \"John\", \"email\": \"john@example.com\", \"age\": 30 }\r\n// ‚Üí All fields updated\r\n\r\n// PATCH /api/users/123\r\n// { \"age\": 31 }\r\n// ‚Üí Only age updated, name and email stay the same\r\n```\r\n\r\n\r"
  },
  {
    "id": 50,
    "category": "REST API",
    "title": "What are common HTTP status codes?",
    "content": "\r\n**2xx Success:**\r\n- `200 OK` - Request succeeded\r\n- `201 Created` - Resource created\r\n- `204 No Content` - Success, no response body\r\n\r\n**3xx Redirection:**\r\n- `301 Moved Permanently`\r\n- `304 Not Modified` - Cached version valid\r\n\r\n**4xx Client Error:**\r\n- `400 Bad Request` - Invalid request\r\n- `401 Unauthorized` - Authentication required\r\n- `403 Forbidden` - Not allowed\r\n- `404 Not Found` - Resource doesn't exist\r\n- `409 Conflict` - Resource conflict\r\n- `422 Unprocessable Entity` - Validation error\r\n\r\n**5xx Server Error:**\r\n- `500 Internal Server Error` - Server error\r\n- `502 Bad Gateway` - Invalid response from upstream\r\n- `503 Service Unavailable` - Service down\r\n\r\n**Complete Examples:**\r\n\r\n```javascript\r\n// Success responses\r\napp.get('/api/users', (req, res) => {\r\n  res.status(200).json({ users: [] }); // 200 OK\r\n});\r\n\r\napp.post('/api/users', (req, res) => {\r\n  const user = createUser(req.body);\r\n  res.status(201).json(user); // 201 Created\r\n});\r\n\r\napp.delete('/api/users/:id', (req, res) => {\r\n  deleteUser(req.params.id);\r\n  res.status(204).send(); // 204 No Content\r\n});\r\n\r\n// Client error responses\r\napp.post('/api/users', (req, res) => {\r\n  if (!req.body.email) {\r\n    return res.status(400).json({ error: 'Email required' }); // 400 Bad Request\r\n  }\r\n  // ...\r\n});\r\n\r\napp.get('/api/users/:id', (req, res) => {\r\n  const user = getUserById(req.params.id);\r\n  if (!user) {\r\n    return res.status(404).json({ error: 'User not found' }); // 404 Not Found\r\n  }\r\n  res.json(user);\r\n});\r\n\r\napp.post('/api/login', (req, res) => {\r\n  if (!isValidUser(req.body)) {\r\n    return res.status(401).json({ error: 'Invalid credentials' }); // 401 Unauthorized\r\n  }\r\n  // ...\r\n});\r\n\r\napp.delete('/api/users/:id', (req, res) => {\r\n  if (req.user.role !== 'admin') {\r\n    return res.status(403).json({ error: 'Forbidden' }); // 403 Forbidden\r\n  }\r\n  // ...\r\n});\r\n\r\n// Server error responses\r\napp.get('/api/data', async (req, res) => {\r\n  try {\r\n    const data = await fetchData();\r\n    res.json(data);\r\n  } catch (err) {\r\n    res.status(500).json({ error: 'Internal server error' }); // 500 Server Error\r\n  }\r\n});\r\n```\r\n\r\n\r"
  },
  {
    "id": 51,
    "category": "REST API",
    "title": "What is the request flow from frontend to database?",
    "content": "\r\n**Typical flow:**\r\n\r\n1. **Frontend:** User action triggers API call\r\n   ```javascript\r\n   fetch('/api/users', { method: 'POST', body: JSON.stringify(data) })\r\n   ```\r\n\r\n2. **Network:** HTTP request sent to server\r\n\r\n3. **Express Server:**\r\n   - Middleware processes request (CORS, body parser, auth)\r\n   - Route handler receives request\r\n   - Business logic executed\r\n\r\n4. **Database:**\r\n   - Query executed (SQL/NoSQL)\r\n   - Data retrieved/modified\r\n   - Response returned to server\r\n\r\n5. **Server Response:**\r\n   - Data formatted (JSON)\r\n   - HTTP response sent\r\n\r\n6. **Frontend:**\r\n   - Response received\r\n   - UI updated\r\n\r\n**Example:**\r\n```\r\nBrowser ‚Üí Express ‚Üí Controller ‚Üí Service ‚Üí Database\r\n         ‚Üê        ‚Üê            ‚Üê         ‚Üê\r\n```\r\n\r\n\r\n"
  },
  {
    "id": 52,
    "category": "Authentication & Security",
    "title": "What is JWT?",
    "content": "\r\n**JWT (JSON Web Token):**\r\n- A compact, URL-safe token format for securely transmitting information\r\n- Contains claims (user info, permissions)\r\n- Signed with secret/key to prevent tampering\r\n\r\n**Structure:**\r\n```\r\nheader.payload.signature\r\n```\r\n\r\n- **Header:** Algorithm and token type\r\n- **Payload:** Claims (user data, expiration)\r\n- **Signature:** Verifies token hasn't been tampered with\r\n\r\n**Use cases:**\r\n- Authentication (user login)\r\n- Authorization (permissions)\r\n- Stateless sessions\r\n\r\n**Example:**\r\n```javascript\r\n// Create token\r\nconst token = jwt.sign({ userId: 123 }, secret, { expiresIn: '1h' });\r\n\r\n// Verify token\r\nconst decoded = jwt.verify(token, secret);\r\n```\r\n\r\n\r"
  },
  {
    "id": 53,
    "category": "Authentication & Security",
    "title": "Where should JWT be stored?",
    "content": "\r\n**Options:**\r\n\r\n1. **httpOnly cookies (Recommended):**\r\n   - Most secure\r\n   - Not accessible to JavaScript (XSS protection)\r\n   - Sent automatically with requests\r\n\r\n2. **Memory (state):**\r\n   - Secure, not persisted\r\n   - Lost on refresh\r\n   - Good for access tokens\r\n\r\n3. **localStorage:**\r\n   - Accessible to JavaScript\r\n   - Vulnerable to XSS\r\n   - **Not recommended**\r\n\r\n4. **sessionStorage:**\r\n   - Similar to localStorage\r\n   - Cleared on tab close\r\n   - Still vulnerable to XSS\r\n\r\n**Best practice:**\r\n- **Refresh token:** httpOnly cookie\r\n- **Access token:** Memory or httpOnly cookie\r\n- **Never:** localStorage for sensitive tokens\r\n\r\n\r"
  },
  {
    "id": 54,
    "category": "Authentication & Security",
    "title": "What is the difference between authentication and authorization?",
    "content": "\r\n**Authentication:**\r\n- **\"Who are you?\"** - Verifying user identity\r\n- Login process - confirming user is who they claim to be\r\n- Examples: Username/password, OAuth, biometrics\r\n\r\n**Authorization:**\r\n- **\"What can you do?\"** - Determining user permissions\r\n- What resources/actions user can access\r\n- Examples: Admin vs user, role-based access\r\n\r\n**Analogy:**\r\n- **Authentication:** Showing ID to enter building\r\n- **Authorization:** Having key to specific rooms\r\n\r\n**Example:**\r\n```javascript\r\n// Authentication\r\nif (!user) return res.status(401).json({ error: 'Not authenticated' });\r\n\r\n// Authorization\r\nif (user.role !== 'admin') {\r\n  return res.status(403).json({ error: 'Not authorized' });\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 55,
    "category": "Authentication & Security",
    "title": "How do you protect against:",
    "content": "\r\n**SQL Injection:**\r\n- **Use parameterized queries:** Never concatenate user input into SQL\r\n- **ORM/Query builders:** Use Sequelize, TypeORM, Prisma\r\n- **Input validation:** Validate and sanitize inputs\r\n- **Least privilege:** Database user with minimal permissions\r\n\r\n```javascript\r\n// Bad\r\nconst query = `SELECT * FROM users WHERE id = ${userId}`;\r\n\r\n// Good\r\nconst query = 'SELECT * FROM users WHERE id = ?';\r\ndb.query(query, [userId]);\r\n```\r\n\r\n**XSS (Cross-Site Scripting):**\r\n- **Escape output:** Encode user input before displaying\r\n- **Content Security Policy (CSP):** Restrict script sources\r\n- **Sanitize input:** Remove/escape HTML/JavaScript\r\n- **httpOnly cookies:** Prevent JavaScript access to cookies\r\n\r\n```javascript\r\n// Escape user input\r\nconst safe = escapeHtml(userInput);\r\n```\r\n\r\n**CSRF (Cross-Site Request Forgery):**\r\n- **CSRF tokens:** Unique token per session\r\n- **SameSite cookies:** `SameSite=Strict` attribute\r\n- **Referer header:** Check request origin\r\n- **Double-submit cookies:** Token in cookie and form\r\n\r\n```javascript\r\n// CSRF token middleware\r\napp.use(csrf({ cookie: true }));\r\n```\r\n\r\n\r"
  },
  {
    "id": 56,
    "category": "Authentication & Security",
    "title": "Why should passwords not be stored as plain text?",
    "content": "\r\n**Security risks:**\r\n\r\n1. **Database breach:** If database is compromised, all passwords exposed\r\n2. **Insider threat:** Anyone with DB access sees passwords\r\n3. **Password reuse:** Users reuse passwords across sites\r\n4. **Compliance:** Violates security standards (PCI-DSS, GDPR)\r\n\r\n**Solution: Hashing**\r\n- Use **bcrypt**, **argon2**, or **scrypt**\r\n- One-way function (can't reverse)\r\n- Add **salt** (random data) to prevent rainbow table attacks\r\n- **Never** use MD5, SHA1 (too fast, vulnerable)\r\n\r\n**Example:**\r\n```javascript\r\n// Hash password\r\nconst hashed = await bcrypt.hash(password, 10);\r\n\r\n// Verify password\r\nconst isValid = await bcrypt.compare(password, hashed);\r\n```\r\n\r\n\r\n"
  },
  {
    "id": 57,
    "category": "Databases",
    "title": "When would you choose SQL over NoSQL?",
    "content": "\r\n**Choose SQL when:**\r\n- **Structured data:** Well-defined schema\r\n- **Relationships:** Complex relationships between data\r\n- **ACID transactions:** Need strong consistency\r\n- **Complex queries:** JOINs, aggregations, reporting\r\n- **Data integrity:** Foreign keys, constraints important\r\n\r\n**Choose NoSQL when:**\r\n- **Flexible schema:** Structure changes frequently\r\n- **Scalability:** Need horizontal scaling\r\n- **High write volume:** Fast writes (logs, analytics)\r\n- **Simple queries:** Key-value lookups, simple reads\r\n- **Large datasets:** Big data, unstructured data\r\n\r\n**Examples:**\r\n- **SQL:** E-commerce, banking, CRM systems\r\n- **NoSQL:** Social media, IoT, real-time analytics\r\n\r\n\r"
  },
  {
    "id": 58,
    "category": "Databases",
    "title": "What is an index and why is it important?",
    "content": "\r\n**Index:**\r\n- A data structure that improves query performance\r\n- Like an index in a book - helps find data quickly\r\n- Stored separately from table data\r\n\r\n**Why important:**\r\n- **Faster queries:** Especially on large tables\r\n- **Faster JOINs:** Speeds up relationship queries\r\n- **Faster sorting:** Helps ORDER BY operations\r\n- **Unique constraints:** Enforces uniqueness\r\n\r\n**Trade-offs:**\r\n- **Storage:** Takes additional space\r\n- **Write performance:** Slower INSERT/UPDATE (index must update)\r\n\r\n**Example:**\r\n```sql\r\n-- Create index\r\nCREATE INDEX idx_email ON users(email);\r\n\r\n-- Query uses index automatically\r\nSELECT * FROM users WHERE email = 'user@example.com';\r\n```\r\n\r\n\r"
  },
  {
    "id": 59,
    "category": "Databases",
    "title": "What is a JOIN?",
    "content": "\r\n**JOIN:**\r\n- Combines rows from two or more tables based on related columns\r\n- Used to query data from multiple tables\r\n\r\n**Types:**\r\n\r\n1. **INNER JOIN:** Returns matching rows from both tables\r\n2. **LEFT JOIN:** Returns all rows from left table + matching right\r\n3. **RIGHT JOIN:** Returns all rows from right table + matching left\r\n4. **FULL OUTER JOIN:** Returns all rows from both tables\r\n\r\n**Example:**\r\n```sql\r\n-- Get users with their orders\r\nSELECT users.name, orders.total\r\nFROM users\r\nINNER JOIN orders ON users.id = orders.user_id;\r\n```\r\n\r\n\r"
  },
  {
    "id": 60,
    "category": "Databases",
    "title": "How do you model a one-to-many relationship?",
    "content": "\r\n**One-to-many:**\r\n- One record in table A relates to many records in table B\r\n- Example: One user has many orders\r\n\r\n**Implementation:**\r\n- Add **foreign key** in the \"many\" table\r\n- Foreign key references primary key of \"one\" table\r\n\r\n**Example:**\r\n```sql\r\n-- Users table (one)\r\nCREATE TABLE users (\r\n  id INT PRIMARY KEY,\r\n  name VARCHAR(100)\r\n);\r\n\r\n-- Orders table (many)\r\nCREATE TABLE orders (\r\n  id INT PRIMARY KEY,\r\n  user_id INT,  -- Foreign key\r\n  total DECIMAL,\r\n  FOREIGN KEY (user_id) REFERENCES users(id)\r\n);\r\n```\r\n\r\n**In ORM:**\r\n```javascript\r\n// Sequelize example\r\nUser.hasMany(Order);\r\nOrder.belongsTo(User);\r\n```\r\n\r\n\r"
  },
  {
    "id": 61,
    "category": "Databases",
    "title": "What is a transaction?",
    "content": "\r\n**Transaction:**\r\n- A sequence of database operations that execute as a single unit\r\n- **ACID properties:**\r\n  - **Atomicity:** All or nothing\r\n  - **Consistency:** Database remains valid\r\n  - **Isolation:** Concurrent transactions don't interfere\r\n  - **Durability:** Committed changes persist\r\n\r\n**Use cases:**\r\n- Money transfers (debit one account, credit another)\r\n- Order creation (create order, update inventory, charge payment)\r\n- Any operation requiring multiple steps to succeed together\r\n\r\n**Example:**\r\n```javascript\r\n// Transaction ensures both succeed or both fail\r\nawait db.transaction(async (t) => {\r\n  await Account.decrement({ balance: 100 }, { where: { id: 1 }, transaction: t });\r\n  await Account.increment({ balance: 100 }, { where: { id: 2 }, transaction: t });\r\n});\r\n```\r\n\r\n\r\n"
  },
  {
    "id": 62,
    "category": "Performance & Scalability",
    "title": "What happens when many requests hit the server at the same time?",
    "content": "\r\n**Node.js handling:**\r\n\r\n1. **Event loop:**\r\n   - Requests are queued in the event loop\r\n   - Non-blocking I/O allows handling many concurrent requests\r\n   - Single thread processes requests asynchronously\r\n\r\n2. **Concurrency:**\r\n   - Node.js can handle thousands of concurrent connections\r\n   - Limited by available memory and CPU\r\n   - I/O operations don't block the thread\r\n\r\n3. **Bottlenecks:**\r\n   - **CPU-intensive tasks:** Block the event loop\r\n   - **Memory:** Too many requests can exhaust memory\r\n   - **Database:** Database becomes bottleneck\r\n\r\n4. **Solutions:**\r\n   - **Load balancing:** Distribute requests across servers\r\n   - **Clustering:** Multiple Node.js processes\r\n   - **Caching:** Reduce database load\r\n   - **Database connection pooling:** Reuse connections\r\n\r\n**Example with clustering:**\r\n```javascript\r\nconst cluster = require('cluster');\r\nconst numCPUs = require('os').cpus().length;\r\n\r\nif (cluster.isMaster) {\r\n  for (let i = 0; i < numCPUs; i++) {\r\n    cluster.fork();\r\n  }\r\n} else {\r\n  // Worker process\r\n  app.listen(3000);\r\n}\r\n```\r\n\r\n\r"
  },
  {
    "id": 63,
    "category": "Performance & Scalability",
    "title": "How does Node.js handle I/O operations?",
    "content": "\r\n**Non-blocking I/O:**\r\n\r\n1. **Asynchronous operations:**\r\n   - I/O operations (file, network, database) are asynchronous\r\n   - Don't block the main thread\r\n   - Use callbacks, promises, or async/await\r\n\r\n2. **Event loop:**\r\n   - Manages I/O operations\r\n   - When I/O completes, callback is queued\r\n   - Main thread continues processing other requests\r\n\r\n3. **libuv:**\r\n   - C++ library that handles I/O\r\n   - Uses OS-level threads for I/O operations\r\n   - Main JavaScript thread stays free\r\n\r\n**Example:**\r\n```javascript\r\n// Non-blocking file read\r\nfs.readFile('file.txt', (err, data) => {\r\n  // Callback executes when I/O completes\r\n  console.log(data);\r\n});\r\n// Code here executes immediately, doesn't wait for file read\r\n```\r\n\r\n\r"
  },
  {
    "id": 64,
    "category": "Performance & Scalability",
    "title": "How would you improve a slow API?",
    "content": "\r\n**Strategies:**\r\n\r\n1. **Database optimization:**\r\n   - Add indexes on frequently queried columns\r\n   - Optimize queries (avoid N+1 queries)\r\n   - Use connection pooling\r\n   - Consider read replicas\r\n\r\n2. **Caching:**\r\n   - Cache frequently accessed data (Redis, Memcached)\r\n   - Cache API responses\r\n   - Use CDN for static assets\r\n\r\n3. **Code optimization:**\r\n   - Avoid blocking operations\r\n   - Use async/await properly\r\n   - Optimize algorithms\r\n   - Remove unnecessary computations\r\n\r\n4. **Infrastructure:**\r\n   - Load balancing\r\n   - Horizontal scaling (more servers)\r\n   - Database sharding\r\n   - Use faster hardware\r\n\r\n5. **API design:**\r\n   - Pagination for large datasets\r\n   - Field selection (only return needed data)\r\n   - Compression (gzip)\r\n   - HTTP/2\r\n\r\n**Example:**\r\n```javascript\r\n// Add caching\r\nconst cache = require('redis');\r\napp.get('/api/data', async (req, res) => {\r\n  const cached = await cache.get('data');\r\n  if (cached) return res.json(JSON.parse(cached));\r\n  \r\n  const data = await fetchFromDB();\r\n  await cache.set('data', JSON.stringify(data), 'EX', 3600);\r\n  res.json(data);\r\n});\r\n```\r\n\r\n\r\n"
  },
  {
    "id": 65,
    "category": "Full-Stack Questions",
    "title": "How does React communicate with Node.js?",
    "content": "\r\n**Communication flow:**\r\n\r\n1. **HTTP requests:**\r\n   - React makes HTTP requests (fetch, axios) to Node.js API\r\n   - Node.js Express server handles requests\r\n   - Returns JSON responses\r\n\r\n2. **REST API:**\r\n   - Standard REST endpoints\r\n   - GET, POST, PUT, DELETE methods\r\n   - JSON request/response format\r\n\r\n3. **WebSockets (real-time):**\r\n   - For bidirectional communication\r\n   - Chat, notifications, live updates\r\n   - Socket.io library\r\n\r\n**Example:**\r\n```javascript\r\n// React (frontend)\r\nconst response = await fetch('http://localhost:3000/api/users', {\r\n  method: 'POST',\r\n  headers: { 'Content-Type': 'application/json' },\r\n  body: JSON.stringify({ name: 'John' })\r\n});\r\n\r\n// Node.js (backend)\r\napp.post('/api/users', (req, res) => {\r\n  const user = createUser(req.body);\r\n  res.json(user);\r\n});\r\n```\r\n\r\n\r"
  },
  {
    "id": 66,
    "category": "Full-Stack Questions",
    "title": "Describe a full login flow from frontend to backend.",
    "content": "\r\n**Complete flow:**\r\n\r\n1. **Frontend:**\r\n   ```javascript\r\n   // User submits login form\r\n   const response = await fetch('/api/login', {\r\n     method: 'POST',\r\n     body: JSON.stringify({ email, password })\r\n   });\r\n   const { token, user } = await response.json();\r\n   localStorage.setItem('token', token);\r\n   ```\r\n\r\n2. **Backend receives request:**\r\n   ```javascript\r\n   app.post('/api/login', async (req, res) => {\r\n     const { email, password } = req.body;\r\n   ```\r\n\r\n3. **Validate credentials:**\r\n   ```javascript\r\n     const user = await User.findOne({ email });\r\n     if (!user) return res.status(401).json({ error: 'Invalid credentials' });\r\n     \r\n     const isValid = await bcrypt.compare(password, user.password);\r\n     if (!isValid) return res.status(401).json({ error: 'Invalid credentials' });\r\n   ```\r\n\r\n4. **Generate token:**\r\n   ```javascript\r\n     const token = jwt.sign({ userId: user.id }, secret, { expiresIn: '1h' });\r\n   ```\r\n\r\n5. **Send response:**\r\n   ```javascript\r\n     res.json({ token, user: { id: user.id, email: user.email } });\r\n   });\r\n   ```\r\n\r\n6. **Frontend stores token:**\r\n   - Token stored (httpOnly cookie or memory)\r\n   - Used for subsequent authenticated requests\r\n\r\n7. **Protected routes:**\r\n   ```javascript\r\n   // Backend middleware\r\n   function authenticate(req, res, next) {\r\n     const token = req.headers.authorization?.split(' ')[1];\r\n     const decoded = jwt.verify(token, secret);\r\n     req.userId = decoded.userId;\r\n     next();\r\n   }\r\n   ```\r\n\r\n\r"
  },
  {
    "id": 67,
    "category": "Full-Stack Questions",
    "title": "How do you handle errors on frontend and backend?",
    "content": "\r\n**Backend error handling:**\r\n\r\n```javascript\r\n// Error middleware\r\napp.use((err, req, res, next) => {\r\n  console.error(err.stack);\r\n  \r\n  // Don't leak error details in production\r\n  res.status(err.status || 500).json({\r\n    error: process.env.NODE_ENV === 'production' \r\n      ? 'Internal server error' \r\n      : err.message\r\n  });\r\n});\r\n\r\n// Async error wrapper\r\nconst asyncHandler = (fn) => (req, res, next) => {\r\n  Promise.resolve(fn(req, res, next)).catch(next);\r\n};\r\n```\r\n\r\n**Frontend error handling:**\r\n\r\n```javascript\r\n// Try-catch in components\r\ntry {\r\n  const data = await fetchData();\r\n  setData(data);\r\n} catch (error) {\r\n  setError(error.message);\r\n  // Show user-friendly error message\r\n}\r\n\r\n// Global error boundary (React)\r\nclass ErrorBoundary extends React.Component {\r\n  state = { hasError: false };\r\n  \r\n  static getDerivedStateFromError(error) {\r\n    return { hasError: true };\r\n  }\r\n  \r\n  render() {\r\n    if (this.state.hasError) {\r\n      return <ErrorFallback />;\r\n    }\r\n    return this.props.children;\r\n  }\r\n}\r\n```\r\n\r\n**Best practices:**\r\n- **Backend:** Log errors, return appropriate status codes, don't expose internals\r\n- **Frontend:** Show user-friendly messages, handle network errors, use error boundaries\r\n\r\n\r"
  },
  {
    "id": 68,
    "category": "Full-Stack Questions",
    "title": "How would you split a system into microservices?",
    "content": "\r\n**Microservices architecture:**\r\n- Split monolithic application into small, independent services\r\n- Each service handles a specific business domain\r\n\r\n**Splitting strategy:**\r\n\r\n1. **Domain-driven design:**\r\n   - Identify bounded contexts (User, Order, Payment, Inventory)\r\n   - Each context becomes a service\r\n\r\n2. **Service boundaries:**\r\n   - **User service:** Authentication, user management\r\n   - **Order service:** Order processing\r\n   - **Payment service:** Payment processing\r\n   - **Product service:** Product catalog\r\n\r\n3. **Communication:**\r\n   - **REST APIs:** HTTP requests between services\r\n   - **Message queues:** RabbitMQ, Kafka for async communication\r\n   - **Service mesh:** For complex inter-service communication\r\n\r\n4. **Data management:**\r\n   - Each service has its own database\r\n   - Avoid shared databases\r\n   - Use API for data access\r\n\r\n5. **Deployment:**\r\n   - Independent deployment\r\n   - Containerization (Docker)\r\n   - Orchestration (Kubernetes)\r\n\r\n**Example structure:**\r\n```\r\nMonolith ‚Üí Microservices\r\n‚îú‚îÄ‚îÄ User Service (port 3001)\r\n‚îú‚îÄ‚îÄ Order Service (port 3002)\r\n‚îú‚îÄ‚îÄ Payment Service (port 3003)\r\n‚îî‚îÄ‚îÄ Product Service (port 3004)\r\n```\r\n\r\n**Benefits:**\r\n- Independent scaling\r\n- Technology diversity\r\n- Fault isolation\r\n- Team autonomy\r\n\r\n**Challenges:**\r\n- Network latency\r\n- Data consistency\r\n- Distributed transactions\r\n- Increased complexity\r\n\r\n\r\n"
  }
]